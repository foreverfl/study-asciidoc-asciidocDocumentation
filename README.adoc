= AsciiDoc
:source-highlighter: highlightjs

== 개요
- AsciiDoc을 공부하기 위한 문서입니다.
- 번역은 GPT4o 및 Claude Sonet을 활용했으며, 어색한 부분은 직접 수정했습니다.

== 목차

- Introduction
  ** xref:document-structure[Document Structure]
  ** xref:key-concepts[Key Concepts]
  ** xref:document-processing[Document Processing]
  ** xref:normalization[Normalization]

- xref:blocks[Blocks]
  ** xref:delimited-blocks[Delimited Blocks]
  ** xref:basic-block[Build a Basic Block]
  ** xref:add-title[Add a Title to a Block]
  ** xref:assign-id[Assign an ID]
  ** xref:block-masquerading[Block Masquerading]
  ** xref:troubleshooting-blocks[Troubleshooting Blocks]

- xref:document-attributes[Document Attributes]
  ** xref:attribute-entries[Attribute Entries]
    *** xref:attribute-entry-names-and-values[Attribute Entry Names and Values]
    *** xref:wrap-attribute-entry-values[Wrap Attribute Entry Values]
    *** xref:attribute-entry-substitutions[Attribute Entry Substitutions]
    *** xref:inline-attribute-entries[Inline Attribute Entries]
  ** xref:declare-built-in-attributes[Declare Built-In Attributes]
    *** xref:set-boolean-attributes[Set Boolean Attributes]
  ** xref:declare-custom-attributes[Declare Custom Attributes]
  ** xref:unset-attributes[Unset Attributes]
  ** xref:reference-attributes[Reference Attributes]
    *** xref:handle-unresolved-references[Handle Unresolved References]
  ** xref:attribute-assignment-precedence[Attribute Assignment Precedence]
  ** xref:counters[Counters]

- xref:element-attributes[Element Attributes]
  ** xref:positional-and-named-attributes[Positional and Named Attributes]
  ** xref:id-attribute[ID Attribute]
  ** xref:role-attribute[Role Attribute]
  ** xref:options-attribute[Options Attribute]

- xref:document-header[Document Header]
  ** xref:document-title[Document Title]
    *** xref:subtitle[Subtitle]
  ** xref:author-information[Author Information]
    *** xref:using-the-author-line[Using the Author Line]
    *** xref:add-multiple-authors-to-a-document[Add Multiple Authors to a Document]
    *** xref:assign-author-and-email-with-attribute-entries[Assign Author and Email with Attribute Entries]
    *** xref:reference-the-author-information[Reference the Author Information]
    *** xref:compound-author-names[Compound Author Names]
  ** xref:revision-information[Revision Information]
    *** xref:using-the-revision-line[Using the Revision Line]
    *** xref:assign-revision-attributes-with-attribute-entries[Assign Revision Attributes with Attribute Entries]
    *** xref:version-label-attribute[Version Label Attribute]
    *** xref:reference-the-revision-attributes[Reference the Revision Attributes]
  ** xref:document-metadata[Document Metadata]
  ** xref:document-header-reference[Document Header Reference]

- xref:document-type[Document Type]

- xref:sections[Sections]
  ** xref:section-titles-and-levels[Section Titles and Levels]
    *** xref:activate-section-title-links[Activate Section Title Links]

  ** xref:autogenerate-section-ids[Autogenerate Section IDs]
    *** xref:change-id-prefix-separator[Change the ID Prefix and Separator]

  ** xref:assign-custom-ids-reference-text[Assign Custom IDs and Reference Text]
  ** xref:section-numbers[Section Numbers]
  ** xref:section-styles-articles-books[Section Styles for Articles and Books]
    *** xref:hide-special-section-titles[Hide Special Section Titles]
    *** xref:number-special-sections[Number Special Sections]
    *** xref:colophon[Colophon]
    *** xref:dedication[Dedication]
    *** xref:abstract-section[Abstract (Section)]
    *** xref:abstract-block[Abstract (Block)]
    *** xref:preface[Preface]
    *** xref:book-parts[Book Parts]
      **** xref:part-numbers-signifier[Part Numbers and Signifier]
    *** xref:chapters[Chapters]
    *** xref:appendix[Appendix]
    *** xref:glossary[Glossary]
    *** xref:bibliography[Bibliography]
    *** xref:index[Index]

  ** xref:section-attributes-styles-reference[Section Attributes and Styles Reference]

- xref:paragraphs[Paragraphs]
  ** xref:hard-line-breaks[Hard Line Breaks]
  ** xref:preamble-lead-style[Preamble and Lead Style]
  ** xref:paragraph-alignment[Paragraph Alignment]

- xref:discrete-headings[Discrete Headings]

- xref:breaks[Breaks]

- xref:text-formatting-punctuation[Text Formatting and Punctuation]
  ** xref:bold[Bold]
  ** xref:italic[Italic]
  ** xref:monospace[Monospace]
  ** xref:literal-monospace[Literal Monospace]
  ** xref:text-span-built-in-roles[Text Span and Built-in Roles]
  ** xref:highlight[Highlight]
  ** xref:quotation-marks-apostrophes[Quotation Marks and Apostrophes]
  ** xref:subscript-superscript[Subscript and Superscript]
  ** xref:using-custom-inline-styles[Using Custom Inline Styles]
  ** xref:troubleshoot-unconstrained-formatting-pairs[Troubleshoot Unconstrained Formatting Pairs]

- Lists
  ** xref:unordered-lists[Unordered Lists]
  ** xref:ordered-lists[Ordered Lists]
  ** xref:checklists[Checklists]
  ** xref:separating-lists[Separating Lists]
  ** xref:complex-list-items[Complex List Items]

- xref:description-lists[Description Lists]
  ** xref:horizontal-description-list[Horizontal Description List]
  ** xref:question-answer-lists[Question and Answer Lists]
  ** xref:description-lists-with-marker[Description Lists With Marker]

- xref:links[Links]
  ** xref:autolinks[Autolinks]
  ** xref:url-macro[URL Macro]
  ** xref:link-macro[Link Macro]
  ** xref:troubleshooting-complex-urls[Troubleshooting Complex URLs]
  ** xref:link-url-macro-attribute-parsing[Link & URL Macro Attribute Parsing]
  ** xref:mailto-macro[Mailto Macro]
  ** xref:link-url-mailto-macro-attributes-reference[Link, URL, and Mailto Macro Attributes Reference]

- xref:cross-references[Cross References]
  ** xref:document-to-document-cross-references[Document to Document Cross References]
  ** xref:cross-reference-text-styles[Cross Reference Text and Styles]
  ** xref:validate-cross-references[Validate Cross References]

- xref:footnotes[Footnotes]

- xref:images[Images]
  ** xref:set-the-images-directory[Set the Images Directory]
  ** xref:insert-images-from-a-url[Insert Images from a URL]
  ** xref:position-and-frame-images[Position and Frame Images]
  ** xref:add-link-to-image[Add Link to Image]
  ** xref:adjust-image-sizes[Adjust Image Sizes]
  ** xref:specify-image-format[Specify Image Format]
  ** xref:svg-images[SVG Images]
  ** xref:images-reference[Images Reference]

- xref:audio-and-video[Audio and Video]

- xref:icons[Icons]
  ** xref:image-icons-mode[Image Icons Mode]
  ** xref:font-icons-mode[Font Icons Mode]
  ** xref:icon-macro[Icon Macro]

- xref:keyboard-macro[Keyboard Macro]

- xref:button-menu-ui-macros[Button and Menu UI Macros]

- xref:admonitions[Admonitions]

- xref:sidebars[Sidebars]

- xref:example-blocks[Example Blocks]

- xref:blockquotes[Blockquotes]

- xref:verses[Verses]

- xref:verbatim-source-blocks[Verbatim and Source Blocks]
  ** xref:source-code-blocks[Source Code Blocks]
    *** xref:source-highlighting[Source Highlighting]
    *** xref:highlight-select-lines[Highlight Select Lines]
    *** xref:highlight-php-source-code[Highlight PHP Source Code]
  ** xref:listing-blocks[Listing Blocks]
  ** xref:literal-blocks[Literal Blocks]
  ** xref:callouts[Callouts]

- xref:tables[Tables]
  ** xref:build-basic-table[Build a Basic Table]
  ** xref:add-a-title[Add a Title]
    *** xref:customize-title-label[Customize the Title Label]
    *** xref:turn-off-title-label[Turn Off the Title Label]
  ** xref:add-columns-table[Add Columns to a Table]
    *** xref:adjust-column-widths[Adjust Column Widths]
    *** xref:align-content-column[Align Content by Column]
    *** xref:format-content-column[Format Content by Column]
  ** xref:add-cells-rows-table[Add Cells and Rows to a Table]
    *** xref:create-header-row[Create a Header Row]
    *** xref:create-footer-row[Create a Footer Row]
    *** xref:align-content-cell[Align Content by Cell]
    *** xref:format-content-cell[Format Content by Cell]
    *** xref:span-columns-rows[Span Columns and Rows]
    *** xref:duplicate-cells[Duplicate Cells]
  ** xref:table-width[Table Width]
  ** xref:table-borders[Table Borders]
  ** xref:table-striping[Table Striping]
  ** xref:table-orientation[Table Orientation]
  ** xref:assign-role-table[Assign a Role to a Table]
  ** xref:nesting-tables[Nesting Tables]
  ** xref:csv-tsv-dsv-data[CSV, TSV and DSV Data]
  ** xref:table-reference[Table Reference]

- xref:equations-formulas[Equations and Formulas (STEM)]

- xref:open-blocks[Open Blocks]

- xref:collapsible-blocks[Collapsible Blocks]

- xref:comments[Comments]

- xref:automatic-toc[Automatic Table of Contents]
  ** xref:customize-toc-title[Customize the TOC Title]
  ** xref:adjust-toc-depth[Adjust the TOC Depth]
  ** xref:position-toc[Position the TOC]
  ** xref:toc-attributes-reference[TOC Attributes Reference]

- xref:docinfo-files[Docinfo Files]

- xref:includes[Includes]
  ** xref:offset-section-levels[Offset Section Levels]
  ** xref:indent-included-content[Indent Included Content]
  ** xref:use-include-file-multiple-times[Use an Include File Multiple Times]
  ** xref:include-list-item-content[Include List Item Content]
  ** xref:include-content-tagged-regions[Include Content by Tagged Regions]
  ** xref:include-content-line-ranges[Include Content by Line Ranges]
  ** xref:include-content-uri[Include Content by URI]

- xref:conditionals[Conditionals]
  ** xref:ifdef-directives[ifdef and ifndef Directives]
  ** xref:ifeval-directive[ifeval Directive]

- xref:substitutions[Substitutions]
  ** xref:special-characters[Special Characters]
  ** xref:quotes[Quotes]
  ** xref:attribute-references[Attribute References]
  ** xref:character-replacements[Character Replacements]
  ** xref:macros[Macros]
  ** xref:post-replacements[Post Replacements]
  ** xref:customize-substitutions-blocks[Customize the Substitutions Applied to Blocks]
  ** xref:customize-substitutions-text[Customize the Substitutions Applied to Text]
  ** xref:escape-prevent-substitutions[Escape and Prevent Substitutions]

- xref:passthroughs[Passthroughs]
  ** xref:passthrough-blocks[Passthrough Blocks]
  ** xref:inline-passthroughs[Inline Passthroughs]

- xref:reference[Reference]
  ** xref:syntax-quick-reference[Syntax Quick Reference]
  ** xref:faq[Frequently Asked Questions (FAQ)]
  ** xref:compare-asciidoc-markdown[Compare AsciiDoc to Markdown]
  ** xref:document-attributes-reference[Document Attributes Reference]
  ** xref:character-replacement-attributes-reference[Character Replacement Attributes Reference]
  ** xref:reference-glossary-of-terms[Glossary of Terms]


[[document-structure]]
== Introduction - Document Structure

=== AsciiDoc 소개

AsciiDoc은 주로 기술 문서 작성을 위해 설계된 경량의 시맨틱 마크업 언어입니다. 간결하고 사람이 읽기 쉬운 일반 텍스트 형식으로 인코딩된 콘텐츠에서 다양한 프레젠테이션이 풍부한 출력 형식을 생성할 수 있습니다.

AsciiDoc 문법은 텍스트를 마크업하고 구조화하는 데 잘 확립된 일반 텍스트 규칙을 기반으로 하기 때문에 직관적입니다. AsciiDoc에 익숙하지 않은 사람도 아마도 구문 요소를 보기만 해도 그 목적을 추측할 수 있을 것입니다. 기술 업계에서 오랫동안 사용해 온 관행인, 구문 요소가 의미하는 바를 보이도록 신중하게 선택되었기 때문입니다.

AsciiDoc 언어는 생성하는 출력 형식에 결합되지 않습니다. AsciiDoc 프로세서는 AsciiDoc 소스 문서를 파싱하고 이해한 다음, 파싱된 문서 구조를 HTML, PDF, EPUB3, man(ual) 페이지 또는 DocBook과 같은 하나 이상의 출력 형식으로 변환할 수 있습니다. 여러 출력 형식을 생성할 수 있는 기능은 AsciiDoc의 주요 장점 중 하나입니다. 이 기능 덕분에 정적 사이트 생성기, IDE, Git 도구 및 서비스, CI/CD 시스템 및 기타 소프트웨어에서 사용할 수 있습니다.

AsciiDoc은 쉽게 작성할 수 있는 것과 기술 저작 및 출판의 엄격한 요구 사항 사이의 격차를 해소합니다. AsciiDoc은 읽거나 쓰는 데 텍스트 편집기만 필요하므로 시작하는 데 진입 장벽이 낮습니다.

=== 이 문서에 대하여

여러분은 Asciidoctor에서 구현된 대로 AsciiDoc 언어에 대한 사용자 중심 문서를 읽고 있습니다. 이 문서는 AsciiDoc 콘텐츠를 처리하기 위해 Asciidoctor를 설정하고 사용하는 방법을 다루지 않습니다. 해당 문서는 이 웹사이트의 Asciidoctor 섹션에서 찾을 수 있습니다.

이 문서는 Eclipse의 AsciiDoc Language 프로젝트에 대한 초기 기여로 제출되었습니다. 해당 프로젝트는 이 문서를 바탕으로 AsciiDoc 언어 사양을 작성할 것입니다. 또한 AsciiDoc Language에 대한 사용자 가이드 초안으로 사용될 것이며, 해당 프로젝트에서도 유지 관리될 예정입니다.

AsciiDoc Language 사양의 첫 번째 버전이 비준될 때까지 AsciiDoc은 Asciidoctor 구현에 의해 정의됩니다. 다른 공식적인 언어 정의는 없습니다.

AsciiDoc Language 프로젝트가 AsciiDoc Language에 대한 자체 문서를 게시하기 시작할 때까지 AsciiDoc 문서는 이 사이트에 남아 있을 것입니다.

그때까지, 시작해 보겠습니다!

[[key-concepts]]
== Introduction - Key Concepts

이 페이지에서는 AsciiDoc 문서의 전체 구조에 대해 배웁니다. 지금 당장은 구문의 세부 사항에 대해 걱정하지 마세요. 해당 주제는 이후 문서에서 철저히 다룰 것입니다. 지금은 AsciiDoc 문서를 구성하는 것이 무엇인지 감을 잡는 것을 목표로 합니다.

=== 문서

AsciiDoc은 상용구나 프롤로그가 없는 일반 텍스트 작성 형식입니다. AsciiDoc 문서는 단 하나의 문장(또는 학술적으로는 단 하나의 문자)으로만 구성될 수 있습니다.

다음 예는 하나의 문장을 포함하는 하나의 단락으로 구성된 유효한 AsciiDoc 문서입니다:

[source,asciidoc]
----
This is a basic AsciiDoc document.
----

물론 단일 문장 이상의 내용을 가질 수 있습니다. 여기서 강조하고 싶은 점은 시작하기가 쉽다는 것입니다.

AsciiDoc 문서는 서로 위에 쌓여 있는 일련의 블록(행 단위)입니다. 이러한 블록은 일반적으로 빈 행으로 서로 구분됩니다(특정 상황에서는 선택 사항일 수 있음).

이전 문서를 하나의 단락에서 두 개의 단락으로 확장하려면 빈 행으로 두 단락을 구분하면 됩니다:

[source,asciidoc]
----
This is a basic AsciiDoc document.

This document contains two paragraphs.
----

AsciiDoc 문서는 문서 헤더로 시작할 수 있습니다. 문서 헤더는 선택 사항이지만 문서 제목을 지정하고 문서 전체 구성과 문서 속성 형태의 재사용 가능한 텍스트를 설정할 수 있으므로 자주 사용됩니다.

[source,asciidoc]
----
= Document Title
:reproducible:

This is a basic AsciiDoc document by {author}.

This document contains two paragraphs.
It also has a header that specifies the document title.
----

거의 모든 블록의 조합이 유효한 AsciiDoc 문서를 구성합니다(문서 유형에 따라 일부 구조적 요구 사항이 있음). 문서는 단일 문장부터 여러 부분으로 구성된 책까지 다양할 수 있습니다.

=== 행

행은 AsciiDoc에서 중요한 구성 요소입니다. 행은 줄 바꿈 문자나 문서의 경계로 양쪽이 구분된 텍스트로 정의됩니다. 구문의 많은 측면이 전체 행을 차지해야 합니다. 그래서 AsciiDoc이 행 지향 언어라고 말하는 것입니다.

예를 들어, 섹션 제목은 그 자체로 한 행에 있어야 합니다. 속성 항목, 블록 제목, 블록 속성 목록, 블록 매크로, 목록 항목, 블록 구분 기호 등에도 동일하게 적용됩니다.

Example 1. 단일 행을 차지해야 하는 섹션 제목의 예
[source,asciidoc]
----
== Section Title
----

Example 2. 적어도 하나의 행을 차지해야 하는 속성 항목의 예
[source,asciidoc]
----
:name: value
----

Example 3. 두 행으로 확장되는 속성 항목의 예
[source,asciidoc]
----
:name: value \
more value
----

빈 행도 중요할 수 있습니다. 단일 빈 행은 헤더와 본문을 구분합니다. 앞서 두 단락 예제에서 보았듯이 많은 블록도 빈 행으로 구분됩니다.

반대로 단락 내용 내의 행은 중요하지 않습니다. AsciiDoc 구문을 배우면서 이러한 점을 염두에 두세요.

=== 블록

AsciiDoc 문서의 블록은 문서 구조를 형성합니다. 일부 블록은 다른 블록을 포함할 수 있으므로 문서 구조는 본질적으로 계층적입니다(즉, 트리 구조). 예를 들어, 자동 목차를 활성화하여 이 섹션 구조를 미리 볼 수 있습니다. 블록의 예로는 단락, 섹션, 목록, 구분 블록, 표 및 블록 매크로가 있습니다.

블록은 일반적으로 빈 행으로 다른 블록과 구분되기 때문에 식별하기 쉽습니다(항상 필요한 것은 아님). 블록은 항상 새 행에서 시작하고 행 끝에서 종료되며 왼쪽 여백에 맞춰집니다.

모든 블록에는 하나 이상의 블록 메타데이터 행이 있을 수 있습니다. 이 메타데이터는 블록 속성, 블록 앵커 또는 블록 제목의 형태일 수 있습니다. 이러한 메타데이터 행은 블록 자체 위에 직접 인접해야 합니다.

섹션, 비 verbatim 구분 블록 및 AsciiDoc 테이블 셀은 다른 블록을 포함할 수 있습니다. 블록이 계층을 형성함에도 불구하고 중첩된 블록조차도 왼쪽 여백에서 시작합니다. 블록이 왼쪽 여백에서 시작하도록 요구함으로써 들여쓰기 수준을 추적하고 유지 관리해야 하는 지루함을 피하고 내용을 더 재사용 가능하게 만듭니다.

=== 텍스트와 인라인 요소

마커, 구분 기호 및 메타데이터 행으로 둘러싸인 것은 텍스트입니다. 텍스트는 문서의 주요 초점이며 AsciiDoc 구문이 숨 쉴 공간을 많이 제공하는 이유입니다. 텍스트는 대부분 블록(예: 단락)의 행, 블록 제목(예: 섹션 제목) 및 목록 항목에서 찾을 수 있지만 다른 위치에도 존재할 수 있습니다.

텍스트는 치환의 대상이 됩니다. 치환은 마크업을 텍스트 서식으로 해석하고, 매크로를 텍스트 또는 비텍스트 요소로 대체하고, 속성 참조를 확장하고, 기타 유형의 텍스트 대체를 수행합니다.

달리 지정하지 않는 한 일반 텍스트는 모든 치환의 대상이 됩니다. verbatim 텍스트는 소스에 나타나는 대로 출력에 표시할 수 있도록 최소한의 치환 세트의 대상이 됩니다. 또한 모든 치환을 비활성화하여 텍스트를 수정하지 않고 출력에 전달할 수 있습니다(즉, raw). 텍스트 구문 분석은 인라인 요소와 기타 형태의 변환이 혼합된 것으로 끝납니다.

=== 인코딩과 AsciiDoc 파일

AsciiDoc 파일은 .adoc 파일 확장자를 가진 텍스트 파일입니다(예: document.adoc). 대부분의 AsciiDoc 프로세서는 파일의 텍스트가 UTF-8 인코딩을 사용한다고 가정합니다. UTF-16 인코딩은 파일이 BOM으로 시작하는 경우에만 지원됩니다.

AsciiDoc 프로세서는 문자열(즉, 문자 시퀀스)에서 AsciiDoc을 처리할 수 있습니다. 그러나 대부분의 경우 AsciiDoc 문서를 파일로 저장합니다.

[[document-processing]]
== Introduction - Document Processing

AsciiDoc은 특별히 출판 형식이 아닌 작성 형식입니다. 다시 말해, 워드 프로세서에서 작성할 때처럼 WYSIWYG 방식이 아닙니다. 대신 작성하는 것은 AsciiDoc 소스입니다. 그런 다음 Asciidoctor와 같은 AsciiDoc 프로세서를 사용하여 AsciiDoc 소스를 출판 가능한 형식으로 변환합니다. 출판하는 것은 이 출력물입니다.

AsciiDoc 소스를 변환하는 것은 입력한 것보다 더 많은 것을 얻기 위해 내용을 해석하고 꾸미는 기회입니다. AsciiDoc 소스를 다른 형식으로 변환하는 작업은 변환기에 의해 처리됩니다. 언어와 변환기 사이에는 강력한 관계가 있지만 이 두 측면은 명시적으로 결합되지 않습니다.

AsciiDoc 프로세서는 HTML 및 DocBook을 만드는 것을 포함하여 여러 내장 변환기를 제공합니다. 이러한 변환기 중 하나를 활성화하려면 문서에 백엔드를 설정합니다(기본값: html). 백엔드는 프로세서에게 원하는 출력 형식을 알려주는 키워드입니다. 그런 다음 프로세서는 해당 출력 형식을 만드는 변환기를 선택합니다. 예를 들어 HTML 변환기는 html 백엔드를 처리하여 HTML 출력을 만듭니다.

AsciiDoc 프로세서는 실제로 두 단계로 작동합니다. 첫째, AsciiDoc 문서를 파싱합니다. 이 파싱은 작성된 구조를 반영하고 모든 의미 있는 마크업을 해석하는 구조화된 문서를 생성합니다. 그런 다음 프로세서는 이 구조화된 문서를 변환기에 전달하여 출력 형식으로 변환합니다.

요약하면, 프로세서는 문자열(파일에서 읽을 수 있음)을 받아들이고, 이를 구조 문서로 파싱한 다음, 다른 문자열(파일에 쓸 수 있음)을 생성합니다.

[[normalization]]
== Introduction - Normalization

AsciiDoc 프로세서가 AsciiDoc 소스를 읽을 때, 가장 먼저 하는 일은 행을 정규화하는 것입니다. (이 작업은 미리 수행하거나 각 행을 방문할 때 수행할 수 있습니다).

정규화는 다음 작업으로 구성됩니다:

- 인코딩을 UTF-8로 강제 설정 (AsciiDoc 프로세서는 항상 내용이 UTF-8로 인코딩되어 있다고 가정함)
- 각 행에서 후행 공백 제거 (줄 바꿈 문자 포함)

이 정규화는 구조화된 컨텍스트와 관계없이 수행됩니다. 행이 리터럴 블록의 일부인지 일반 단락의 일부인지는 중요하지 않습니다. 모든 행이 정규화됩니다.

포함 파일의 행에는 특정 경우에만 정규화가 적용됩니다. 인식된 AsciiDoc 확장자를 가진 포함 파일만 위에서 설명한 대로 정규화됩니다. 다른 모든 파일의 경우 후행 줄 바꿈 문자만 제거됩니다. 포함 파일은 인코딩 속성을 사용하여 지정된 다른 인코딩을 가질 수도 있습니다. 인코딩 속성이 지정되지 않은 경우 UTF-8이 가정됩니다.

AsciiDoc 프로세서가 렌더링된 문서(HTML, DocBook 등)를 생성하기 위해 행을 다시 결합할 때, 줄 바꿈 문자(\n)에서 행을 연결합니다.



== Blocks
[[blocks]]

블록 요소는 AsciiDoc 문서의 기본 구조를 형성하며, 문서 자체에서 시작합니다.

=== 블록이란 무엇인가요?

블록 요소(블록이라고도 함)는 AsciiDoc 문서에서 개별적이고 행 지향적인 콘텐츠 덩어리입니다. 일단 파싱되면, 그 콘텐츠 덩어리는 파싱된 문서 모델의 블록 요소가 됩니다. 특정 블록은 다른 블록을 포함할 수 있으므로 블록이 중첩될 수 있다고 말합니다. 변환기는 문서 순서대로 각 블록을 차례로 방문하여 해당하는 출력 덩어리로 변환합니다.

=== 블록 형식

AsciiDoc 구문에서 블록의 경계가 정의되는 방식은 다양합니다. 목록, 단락, 블록 매크로와 같은 일부 블록의 경계는 암시적입니다. 다른 블록은 구분 기호를 사용하여 명시적으로 표시된 경계를 가집니다(즉, 구분된 블록). 주된 공통점은 블록이 항상 행 지향적이라는 것입니다.

단락 블록은 연속적인(비어 있지 않은) 행의 개별 집합으로 정의됩니다. 구분된 블록은 구분 기호 행으로 둘러싸여 있습니다. 섹션 블록(섹션이라고도 함)은 하나 이상의 등호로 시작하는 섹션 제목으로 정의됩니다. 섹션에는 섹션 제목 행 다음부터 다음 형제 또는 부모 섹션 제목이나 문서 경계까지의 모든 내용이 포함됩니다. 목록 블록은 마커로 표시된 형제 목록 항목 그룹으로 정의됩니다. 설명 목록 블록은 하나 이상의 용어로 표시된 형제 목록 항목 그룹으로 정의됩니다. 블록 매크로는 블록 매크로 구문과 일치하는 단일 행으로 정의됩니다. 그리고 문서 자체도 블록입니다.

블록(메타데이터 행 포함)은 항상 양쪽에 빈 행이나 문서 경계로 둘러싸여야 합니다.

블록이 중첩된 블록을 지원하는지 여부는 블록의 콘텐츠 모델(및 구문이 허용하는 내용)에 따라 달라집니다.

=== 콘텐츠 모델

블록의 콘텐츠 모델은 블록이 가질 수 있는 콘텐츠의 종류(있는 경우)와 해당 콘텐츠가 처리되는 방식을 결정합니다. AsciiDoc의 블록 콘텐츠 모델은 다음과 같습니다:

.복합(compound)
  다른 블록만 포함할 수 있는 블록(예: 섹션)

.단순(simple)
  단락 텍스트의 연속 행으로 처리되는 블록(및 일반 대체 적용)(예: 단락 블록)

.축어(verbatim)
  축어적 텍스트를 포함하는 블록("있는 그대로" 표시)(및 축어적 대체 적용)(예: 목록 블록)

.원시(raw)
  대체 없이 출력으로 직접 전달되는 처리되지 않은 콘텐츠를 포함하는 블록(예: 통과 블록)

.빈(empty)
  콘텐츠가 없는 블록(예: 이미지 블록)

.표(table)
  고정된 구조를 적용하는 표 전용 특수 콘텐츠 모델

콘텐츠 모델은 모든 기본 제공 구문에 대해 유추되지만(컨텍스트에 의해 결정됨), 사용자 정의 블록에 대해서는 구성할 수 있습니다. 블록은 다른 상황에서 다른 콘텐츠 모델을 지원할 수도 있습니다. 상황은 컨텍스트와 스타일에 의해 결정되며, 구분된 블록의 경우 구조적 컨테이너에 의해서도 결정됩니다.

=== 컨텍스트

블록을 예제 블록, 사이드바 블록, 권고 블록 또는 섹션과 같은 이름으로 참조하는 경우가 많을 것입니다. 그 이름은 블록의 컨텍스트입니다.

다음과 같은 일반 섹션을 고려해 보겠습니다:

[source,asciidoc]
----
== Section Title

Content of section.
----

이 블록의 컨텍스트는 섹션입니다. 우리는 종종 컨텍스트를 형용사로 사용하여 블록을 설명하는 섹션(또는 섹션 블록)이라고 말합니다. 이 경우 구문에 의해 컨텍스트가 암시되므로 작성자가 컨텍스트를 지정할 필요가 없습니다.

모든 블록에는 컨텍스트가 있습니다. 컨텍스트는 종종 구문에 의해 암시되지만 특정 경우에는 명시적으로 선언할 수 있습니다. 컨텍스트는 한 종류의 블록을 다른 블록과 구별하는 요소입니다. 컨텍스트를 블록의 유형으로 생각할 수 있습니다.

컨텍스트는 블록 스타일을 사용하여 공통 유형을 공유하는 블록 패밀리를 만들도록 추가로 수정할 수 있습니다. 이는 권고 블록 및 섹션의 경우와 같습니다. 우리는 곧 그 수정자에 대해 다룰 것입니다.

블록의 경우 컨텍스트를 블록 이름이라고 하기도 합니다. 이는 특히 사용자 정의 블록에 대해 이야기할 때 나옵니다. 블록 이름은 추상화의 또 다른 계층일 뿐입니다. 모든 기본 제공 블록 이름은 정확히 하나의 컨텍스트에 매핑됩니다. 그러나 블록 확장은 임의의 블록 이름을 하나 이상의 컨텍스트에 매핑할 수 있습니다. 궁극적으로 사용되는 컨텍스트는 확장의 프로세스 메서드에서 반환되는 내용에 따라 달라집니다. 결국 블록이 변환되는 방식을 결정하는 것은 컨텍스트입니다.

컨텍스트는 종종 콘텐츠 모델을 결정합니다. 예를 들어, 모든 섹션은 섹션이 다른 블록만 포함할 수 있기 때문에 암시적으로 복합 콘텐츠 모델을 가집니다. 모든 리터럴 블록은 이 블록의 목적이 축어적 출력을 제공하는 것이기 때문에 암시적으로 축어적 콘텐츠 모델을 가집니다.

==== 기본 제공 컨텍스트 요약

AsciiDoc에서 모든 기본 제공 블록의 컨텍스트 목록은 다음과 같습니다.

[NOTE]
====
Asciidoctor API에서 컨텍스트는 기호로 표현됩니다. Ruby에서 기호는 콜론 접두사가 붙은 이름입니다(예: :listing). 이 문서에서는 컨텍스트의 이름을 참조할 때 이 표기법을 사용하기도 합니다. 그러나 이 표기법은 보편적이지 않습니다. Asciidoctor.js와 같은 일부 프로세서는 대신 문자열로 컨텍스트를 저장합니다.
====

.기본 제공 컨텍스트

|===
| Name | Purpose

| admonition
| 다섯 가지 권고 블록 중 하나.

| audio
| 오디오 블록.

| colist
| 콜아웃 목록.

| dlist
| 설명 목록.

| document
| 최상위 문서 또는 AsciiDoc 표 셀의 문서

| example
| 예제 블록.

| floating_title
| 개별 제목.

| image
| 이미지 블록.

| list_item
| 정렬된 목록, 정렬되지 않은 목록 또는 설명 목록의 항목(목록 또는 설명 목록 블록 내에서만 관련됨). 설명 목록에서 이 블록은 용어와 설명을 나타내는 데 사용됩니다.

| listing
| 목록 블록.

| literal
| 리터럴 블록.

| olist
| 정렬된 목록.

| open
| 열린 블록.

| page_break
| 페이지 나누기.

| paragraph
| 단락.

| pass
| 통과 블록.

| preamble
| 문서의 서문.

| quote
| 인용 블록(blockquote라고도 함).

| section
| 섹션. 부분, 장 또는 특수 섹션일 수도 있습니다.

| sidebar
| 사이드바 블록.

| table
| 표 블록.

| table_cell
| 표 셀(표 블록 내에서만 관련됨).

| thematic_break
| 주제 구분선(수평 규칙이라고도 함).

| toc
| 사용자 정의 TOC 배치를 지정하기 위한 TOC 블록.

| ulist
| 정렬되지 않은 목록.

| verse
| 시 블록.

| video
| 비디오 블록.
|===

[NOTE]
====
각 인라인 요소에도 컨텍스트가 있지만 해당 요소는 (아직) 파싱된 문서 모델에서 접근할 수 없습니다.
====

block, block macro 또는 inline macro 확장 지점을 사용하여 추가 컨텍스트가 도입될 수 있습니다.

==== 변환기에서 사용되는 컨텍스트

컨텍스트는 변환기가 convert 메서드로 전달하는 데 사용하는 것입니다. 그런 다음 스타일은 변환기가 같은 패밀리의 블록에 특수 동작을 적용하는 데 사용됩니다.

두 가지 예외를 제외하고 컨텍스트와 변환기의 처리기 메서드 간에는 1대1 매핑이 있습니다. 이러한 예외는 list_item 및 table_cell 컨텍스트이며 처리기 메서드에 매핑되지 않습니다. 변환기에서 이러한 블록은 부모 블록에서 접근해야 합니다.


=== 블록 스타일

컨텍스트가 항상 블록의 정체성에 대한 전체 이야기를 전달하는 것은 아닙니다. 일부 블록에는 특수화가 필요합니다. 여기서 블록 스타일이 작용합니다.

일부 블록 위에서 블록 속성 목록의 시작 부분에 이름(예: `[source]` 또는 `[verse]`)을 볼 수 있습니다. 블록 속성 목록의 첫 번째 위치 기반(명명되지 않은) 속성은 블록 스타일을 선언하는 데 사용됩니다.

선언된 블록 스타일은 작성자가 제공하는 값입니다. 그런 다음 그 값은 해석되고 확인됩니다. 확인된 블록 스타일이 비어 있지 않으면 블록의 컨텍스트를 특수화합니다. (대신 또는 추가로 블록의 컨텍스트를 변경할 수도 있습니다).

다음 소스 블록의 예를 고려해 보겠습니다:
[source,asciidoc]
----
[source,ruby]
\----
puts "Hello, World!"
\----
----

소스 블록의 컨텍스트는 listing(블록 구분 기호에서 유추됨)이고 스타일은 source(작성자가 지정한 대로)입니다. 우리는 스타일이 블록을 소스 블록으로 특수화한다고 말합니다. (기술적으로 소스 언어가 있으면 소스 스타일이 이미 암시되지만 내부적으로 이렇게 처리됩니다). 블록의 컨텍스트는 여전히 동일하지만 특별한 처리가 필요함을 나타내는 추가 메타데이터가 있습니다.

우리는 또한 다른 목적으로 블록 스타일이 사용되는 것을 볼 수 있습니다. 섹션 제목 위의 appendix 블록 스타일(예: [appendix])은 섹션을 부록(특수 섹션)으로 특수화하므로 특별한 의미와 동작을 갖습니다. 모델에서 섹션의 스타일은 sectname으로 이중 저장됩니다. 예제 블록 위의 다섯 가지 권고 스타일(예: [TIP]) 중 하나는 예제 블록을 해당 이름(즉, 레이블)의 권고 블록으로 변환합니다. 모델에서 소문자로 된 권고 스타일은 name 속성에 저장됩니다. 정렬되지 않은 목록 또는 정렬된 목록 위의 블록 스타일(예: [circle] 또는 [loweralpha])은 표시될 때 목록 항목 앞에 사용되는 마커를 변경합니다. 설명 목록 위의 블록 스타일(예: [qanda] 및 [horizontal])은 의미 또는 레이아웃을 변경할 수 있습니다.

선언된 블록 스타일은 블록의 컨텍스트를 변경하는 데 사용될 수 있으며, 이를 블록 마스커레이딩이라고 합니다. 리터럴 블록 구분 기호를 사용하는 다음과 같은 목록 블록의 대체 구문을 고려해 보겠습니다.

[source,asciidoc]
----
[listing]
....
a > b
....
----

선언된 블록 스타일이 컨텍스트의 이름과 일치하므로 블록의 컨텍스트는 listing이 되고 확인된 블록 스타일은 설정되지 않은 상태로 유지됩니다. 즉, 확인된 블록 스타일은 선언된 블록 스타일과 다릅니다. 선언된 블록 스타일을 사용하여 블록의 컨텍스트를 변경하는 방법에 대한 자세한 내용은 Block Masquerading을 참조하세요.

블록의 정체성에 대한 완전한 그림을 얻으려면 컨텍스트와 스타일을 모두 고려해야 합니다. 확인된 스타일은 컨텍스트를 특수화하여 특별한 동작이나 의미를 부여합니다.


=== 블록의 공통점

블록은 행 지향 구문의 일부 형식을 사용하여 정의됩니다. 섹션 블록은 섹션 제목 행으로 시작합니다. 구분된 블록은 일치하는 구분 기호 행 쌍으로 둘러싸여 있습니다. 단락 블록은 연속된 행이어야 합니다.

모든 블록은 블록 바로 위에 행 방향으로 쌓인 0개 이상의 메타데이터 행을 수용합니다. 이러한 행은 ID, 제목, 옵션과 같은 블록의 속성을 채웁니다. 이러한 메타데이터 행은 다음과 같습니다:

- 0개 이상의 블록 속성 행(블록의 속성을 채움)
- 선택적 블록 앵커 행
- 선택적 블록 제목 행(많은 블록이 해당하는 캡션도 지원함)
- 선택적 ID
- 선택적 역할 집합
- 선택적 옵션 집합

예를 들어 제목과 ID가 있는 사이드바 블록을 고려해 보겠습니다:
[source,asciidoc]
----
.Styles of music
[#music-styles]
****
Go off on a tangent to describe what a style of music is.
****
----

콘텐츠 처리와 관련하여 블록은 서로 다른 그룹으로 분리됩니다. 이러한 그룹은 주로 블록의 콘텐츠 모델과 연관되어 있습니다.

단락 블록과 축어적 블록에는 암시적이고 수정 가능한 대체 집합이 있습니다. 대체는 복합 블록(즉, 중첩된 블록을 포함할 수 있는 블록)에는 적용되지 않습니다.


[[delimited-blocks]]
== Blocks - Delimited Blocks
AsciiDoc에서 구분된 블록은 한 쌍의 일치하는 행 구분 기호에 의해 양쪽이 둘러싸인 콘텐츠 영역입니다. 구분된 블록은 다른 블록(예: 여러 단락)을 묶거나 콘텐츠의 콘텐츠 모델(예: 축어적)을 설정하는 데 사용됩니다. 구분된 블록은 AsciiDoc의 모든 블록 유형의 하위 집합입니다.

=== 개요

구분된 블록은 구조적 컨테이너를 사용하여 정의되며, 이는 AsciiDoc 구문에서 인식되는 고정된 블록 묶음 집합입니다. 다음은 리터럴 블록에 대한 구조적 컨테이너입니다:

[source,asciidoc]
====
....
This text will be treated as verbatim content.
....
====

구조적 컨테이너에는 여는 구분 기호와 닫는 구분 기호가 있습니다. 여는 구분 기호는 블록 메타데이터 뒤에 옵니다(있는 경우). 구조 컨테이너의 앞뒤 빈 줄은 중요하지 않은 것으로 간주되며 자동으로 제거됩니다. 나머지 줄은 블록의 내용을 정의합니다.

이러한 묶음은 블록 내용의 경계를 정의할 뿐만 아니라 콘텐츠 모델(예: 축어적 콘텐츠 또는 하위 트리)을 암시합니다. 특정 경우에는 블록을 중첩하는 메커니즘을 제공합니다. 그러나 구분된 블록은 인터리브될 수 없습니다.

구분된 블록은 내장 매핑과 확장에 의해 정의된 사용자 지정 블록에 대한 매핑을 통해 AsciiDoc 구문에 의해 용도를 변경할 수 있는 고유한 기능을 가지고 있습니다. 구분된 블록이 어떻게 작동하는지 이해하려면 구조적 컨테이너, 행 구분 기호, 기본 컨텍스트, 예상 콘텐츠 모델뿐만 아니라 블록 중첩 및 가장에 대해 이해하는 것이 중요합니다.

=== 행 구분 기호

구분된 블록은 한 쌍의 일치하는 행 구분 기호로 특징 지어집니다. 여는 구분 기호와 닫는 구분 기호는 길이와 문자 순서 모두에서 정확히 일치해야 합니다. 때로는 울타리라고도 하는 이러한 구분 기호는 내용을 둘러싸고 명시적으로 경계를 표시합니다. 구분된 블록의 경계 내에서는 모든 내용이나 빈 줄을 입력할 수 있습니다. 종료 구분 기호가 발견될 때까지 블록이 종료되지 않습니다. 블록 메타데이터(블록 속성 및 앵커 라인)는 여는 구분 기호 위에 위치합니다(따라서 구분된 영역 외부에 있음).

다음은 구분된 예제 블록의 예입니다:

[source,asciidoc]
----
====
This is an example of an example block.
That's so meta.
====
----

일반적으로 구분 기호는 허용되는 최소 길이(현재 고정 길이가 2자인 열린 블록을 제외하고 4자)로 작성됩니다. 구분 기호 줄의 길이는 중첩된 블록을 수용하기 위해 다양하게 변경할 수 있습니다.

구분된 블록을 정의하는 데 사용되는 유효한 구분 기호 집합과 그 의미는 다음에 설명할 사용 가능한 구조적 컨테이너에 의해 정의됩니다.

=== 구조적 컨테이너

구조적 컨테이너는 AsciiDoc 언어에서 정의한 인식된 블록 묶음(구분된 영역)의 고정 집합입니다. 이러한 묶음은 AsciiDoc 구문에서 재사용 가능한 구성 요소를 제공합니다. 구조적 컨테이너와 블록 메타데이터를 평가하여 프로세서는 어떤 종류의 블록을 만들지 결정합니다.

각 구조적 컨테이너에는 예상되는 콘텐츠 모델이 있습니다. 내장 블록의 경우 대부분의 내장 블록이 예상 콘텐츠 모델을 준수하지만 블록의 컨텍스트가 콘텐츠 모델을 결정합니다. 사용자 지정 블록은 콘텐츠 모델을 지정할 수 있습니다. 그러나 이러한 경우에도 콘텐츠 모델은 구조적 컨테이너의 의미를 준수하도록 선택해야 합니다.

일부 구조적 컨테이너는 인용 블록에 대한 구조적 컨테이너가 구절 블록에 사용되는 것과 같이 다른 목적으로 재사용됩니다.

=== 구조적 컨테이너 요약

아래 표는 구조적 컨테이너를 나열하고 각각에 대한 이름, 기본 컨텍스트 및 구분 기호 줄을 기록합니다.

[cols="1,1,1,1", options="header"]
|===
|Type
|Default context
|Content model (expected)
|Minimum delimiter

|comment
|n/a
|n/a
|////

|example
|:example
|compound
|====

|listing
|:listing
|verbatim
|----

|literal
|:literal
|verbatim
|....

|open
|:open
|compound
|--

|sidebar
|:sidebar
|compound
|****

|table
|:table
|table
|=== +
,=== +
:=== +
!===

|pass
|:pass
|raw
|\++++++

|quote
|:quote
|compound
|\____
|===


소스 블록이 없다는 것을 알 수 있습니다. 그것은 소스가 컨테이너 유형이 아니기 때문입니다. 오히려 블록 스타일에 의해 지정된 대로 목록(또는 리터럴) 컨테이너의 특수화입니다. 구절 및 경고 블록도 눈에 띄게 없습니다. 그들은 각각 인용구 및 예제 블록에 대한 구조적 컨테이너의 용도를 변경하기 때문입니다.

명시적 블록 스타일이 없으면 기본 컨텍스트가 가정됩니다.

현재 테이블은 사용자 지정 블록으로 사용될 수 없는 특수 구조적 컨테이너입니다.

다른 구조적 컨테이너와 달리 주석 블록은 구문 분석된 문서에 보존되지 않으므로 컨텍스트나 콘텐츠 모델이 없습니다.

[TIP]
====
사용자 지정 블록을 만들 때는 올바른 콘텐츠 모델을 제공하는 구조적 컨테이너를 선택하는 것이 중요합니다. 이를 통해 텍스트 편집기는 블록을 구문 분석하는 방법을 이해하고 확장이 로드되지 않을 때 합리적인 대체 방법을 제공할 수 있습니다.
====

구조적 컨테이너는 구분된 블록을 정의하는 데 사용됩니다. 구조적 컨테이너는 기본 컨텍스트와 예상 콘텐츠 모델을 제공하지만 실제 컨텍스트와 콘텐츠 모델은 블록의 메타데이터(특히 선언된 블록 콘텐츠)를 고려한 후에 결정됩니다.

=== 블록 중첩

구분된 블록을 사용하면 블록을 서로 중첩할 수 있습니다. (블록은 섹션, 목록 항목 및 테이블 셀 내부에도 중첩될 수 있으며, 이는 별개의 주제입니다).

첫째, 부모 블록은 복합 콘텐츠 모델을 가져야 합니다. 복합 콘텐츠 모델은 블록의 콘텐츠가 0개 이상의 블록 시퀀스임을 의미합니다.

부모와 다른 구조적 컨테이너를 사용하는 블록을 중첩할 때는 자식 블록이 부모 블록 내부에 완전히 있는지 확인하는 것으로 충분합니다. 구분된 블록은 인터리브될 수 없습니다.

[source,asciidoc]
----
====
Here's a sample AsciiDoc document:

=== Document Title
Author Name
Content goes here.
The document header is useful, but not required.
====
----

동일한 구조적 컨테이너를 사용하는 구분된 블록을 중첩할 때는 구분 기호 줄의 길이를 다양하게 변경해야 합니다(즉, 자식 블록의 구분 기호 줄 길이를 부모 블록의 구분 기호 줄 길이와 다르게 만듭니다). 구분 기호 줄 길이를 다양하게 변경하면 파서가 한 블록을 다른 블록과 구별할 수 있습니다.

[source,asciidoc]
----
====
Here are your options:
.Red Pill
[%collapsible]
Escape into the real world.
.Blue Pill
[%collapsible]
Live within the simulated reality without want or fear.
====
----

중첩된 구조적 컨테이너의 구분 기호 길이는 부모보다 짧거나 길 수 있습니다. 그것은 개인적인 스타일 선택입니다.


[[basic-block]]
== Blocks - Build a Basic Block

=== 구분된 블록 만들기

이 섹션에서는 구분된 사이드바 블록을 만들 것입니다. 사이드바 스타일의 구분 기호는 네 개의 별표(\****)입니다.

[start=1]
. 새 줄의 시작 부분에 여는 구분 기호를 입력한 다음 Enter 키를 누릅니다.

[source,asciidoc]
----
Text in your document.

****
----

[start=2]
. 새 줄에 단락, 구분된 블록, 지시문 및 매크로와 같은 내용을 입력합니다. 닫는 구분 기호까지 구분된 블록의 스타일이 이 모든 내용에 적용됩니다.

[source,asciidoc]
----
Text in your document.

This is content in a sidebar block.
image::name.png[]
This is more content in the sidebar block.
----

[start=3]
. 구분된 블록을 종료하려면 마지막 내용 줄의 끝에서 Enter 키를 누릅니다. 새 줄에 닫는 구분 기호를 입력합니다.

[source,asciidoc]
----
Text in your document.

This is content in a sidebar block.
image::name.png[]
This is more content in the sidebar block.
****
----

이것으로 구분된 블록을 만들었습니다.

=== 단락에서 블록 만들기

경우에 따라 스타일의 이름을 사용하여 블록의 스타일을 지정할 수 있습니다. 내용이 연속적이라면(빈 줄이나 주석 줄로 인해 중단되지 않음) 내용 위에 있는 속성 목록에 블록 스타일의 이름을 할당할 수 있습니다. 이 형식은 종종 한 줄 목록에 사용됩니다:
[source,asciidoc]
----
[listing]
sudo dnf install asciidoc
----

또는 한 줄 인용구에 사용됩니다:
[source,asciidoc]
----
[quote]
Never do today what you can put off `'til tomorrow.
----

그러나 스타일이 지정된 단락의 줄은 먼저 단락처럼 구문 분석된 다음 지정된 블록 유형으로 승격된다는 점에 유의하세요. 즉, 줄 주석이 삭제되어 목록 블록과 같은 축어적 블록에 영향을 미칠 수 있습니다. 따라서 특히 축어적 블록을 만들 때는 구분된 블록 형식이 선호됩니다.

=== 내장 블록 요약

다음 표는 내장 블록 스타일, 해당 구분 기호 구문, 목적 및 내용에 대해 수행되는 대체를 식별합니다.

[cols="1,1,1,1,1", options="header"]
|===
|Block |Block Name |Delimiter |Purpose |Substitutions

|Paragraph
|n/a
|n/a
|일반 단락 내용(즉, 산문), 양쪽에 빈 줄로 오프셋됩니다. 문서의 왼쪽 여백에 맞춰 시작해야 합니다. 블록 이름을 사용하여 단락을 대부분의 다른 블록으로 변환할 수 있습니다.
|Normal

|Literal paragraph
|n/a
|n/a
|리터럴 내용(즉, 사전 형식이 지정된 텍스트)을 위한 특수한 유형의 단락 블록입니다. 문서의 왼쪽 여백에서 최소 한 칸 이상 들여쓰기해야 합니다. 내용에 빈 줄이 없을 때 리터럴 구분 블록의 약식으로 자주 사용됩니다.

|Verbatim
|Admonition
|[<LABEL>]
|====
|특별한 주의를 요구하는 부수 내용, 종종 태그나 아이콘으로 레이블이 지정됩니다.
|Normal

|Comment
|n/a
|////
|출력에 표시되지 않는 개인 메모
|None

|Example
|[example]
|====
|예제 내용을 지정하거나 경고 블록을 정의합니다.
|Normal

|Fenced
|n/a
| ```
|소스 코드 또는 키보드 입력이 입력한 대로 표시됩니다. 
|Verbatim

|Listing
|[listing]
|----
|소스 코드 또는 키보드 입력이 입력한 대로 표시됩니다.
|Verbatim

|Literal
|[literal]
|....
|출력 텍스트가 입력한 대로 정확히 표시됩니다.
|Verbatim

|Open
|Most block names
|--
|패스스루 또는 테이블 블록을 제외한 모든 블록 역할을 할 수 있는 익명 블록
|Varies

|Passthrough
|[pass]
|++++
|출력으로 직접 전송되는 처리되지 않은 내용
|None

|Quote
|[quote]
|____
|선택적 속성이 있는 인용구
|Normal

|Sidebar
|[sidebar]
|****
|문서의 흐름 외부에 표시되는 부수 텍스트 및 내용
|Normal

|Source
|[source]
|----
|입력한 대로 표시할 소스 코드 또는 키보드 입력. 문서에서 소스 하이라이터가 활성화되고 언어가 설정된 경우 색상이 지정됩니다.
|Verbatim

|Stem
|[stem]
|++++
|인터프리터(예: AsciiMath 또는 LaTeX 수학)로 직접 전송되는 처리되지 않은 내용
|None

|Table
|n/a
||===
|테이블 내용을 표시합니다.
|Varies

|Verse
|[verse]
|____
|선택적 속성이 있는 시
|Normal
|===



== Blocks - Add a Title to a Block
[[add-title]]
스타일 이름 또는 구분 기호를 사용하여 스타일을 지정하는 것과 관계없이 블록에 제목을 할당할 수 있습니다.
=== 블록 제목 구문
블록 제목은 블록의 속성 목록, 여는 구분 기호 또는 블록 내용 바로 위의 자체 줄에 정의됩니다. 예제 1에 표시된 대로 줄은 점(.)으로 시작하고 바로 뒤에 제목 텍스트가 와야 합니다. 블록 제목은 한 줄만 차지해야 하므로 줄 바꿈할 수 없습니다.
예제 1. 블록 제목 구문
.This is the title of a sidebar block

This is the content of the sidebar block.

다음 섹션에서는 구분된 블록과 속성 목록이 있는 블록에 제목을 추가하는 방법을 보여줍니다.
=== 구분된 블록에 제목 추가
모든 구분된 블록에는 제목이 있을 수 있습니다. 블록에 속성 목록이 없는 경우 여는 구분 기호 바로 위의 새 줄에 제목을 입력합니다. 예제 2의 구분된 리터럴 블록의 제목은 Terminal Output입니다.
예제 2. 구분된 블록에 제목 추가
.Terminal Output
....
From github.com:asciidoctor/asciidoctor

branch        main   -> FETCH_HEAD
Already up to date.
....

블록 제목은 새 줄에 입력됩니다. 제목은 점(.)으로 시작해야 합니다. 점과 제목의 첫 번째 문자 사이에 공백을 넣지 마세요.
블록에 속성을 적용하지 않는 경우 제목 바로 다음 줄에 여는 구분 기호를 입력합니다.
예제 2의 결과는 아래에 표시되어 있습니다.
Terminal Output
From github.com:asciidoctor/asciidoctor

branch        main   -> FETCH_HEAD
Already up to date.

다음 섹션에서는 속성 목록이 있는 블록에 제목이 어떻게 배치되는지 볼 수 있습니다.
=== 속성이 있는 블록에 제목 추가
블록에 속성을 적용할 때 제목은 속성 목록 위의 줄에 배치됩니다. 예제 3은 Specify GitLab CI stages라는 제목의 구분된 소스 코드 블록을 보여줍니다.
예제 3. 구분된 소스 코드 블록에 제목 추가
.Specify GitLab CI stages
[source,yaml]
image: node:16-buster
stages: [ init, verify, deploy ]
블록 제목은 새 줄에 입력됩니다.
블록의 속성 목록은 제목 바로 다음 줄에 입력됩니다.
예제 3의 결과는 아래에 표시되어 있습니다.
Specify GitLab CI stages
image: node:16-buster
stages: [ init, verify, deploy ]
예제 4에 표시된 것처럼 블록이 구분되지 않은 경우 블록의 제목은 속성 목록 위에 배치됩니다.
예제 4. 구분되지 않은 블록에 제목 추가
.Mint
[sidebar]
Mint has visions of global conquest.
If you don't plant it in a container, it will take over your garden.
예제 4의 결과는 아래에 표시되어 있습니다.
Mint
Mint has visions of global conquest. If you don't plant it in a container, it will take over your garden.
이전의 렌더링된 목록 및 소스 블록 예제의 제목과 달리 사이드바의 제목은 가운데 정렬되어 사이드바의 배경 안에 표시된다는 것을 알 수 있습니다. 블록 제목의 표시 방식은 AsciiDoc 문서에 적용하는 변환기와 스타일시트에 따라 다릅니다.
=== 캡션 제목
몇 가지 블록 컨텍스트는 캡션 제목을 지원합니다. 캡션 제목은 캡션 레이블과 숫자 뒤에 점이 오는 제목입니다(예: Table 1. Properties).
캡션 제목은 해당 캡션 속성이 설정된 경우에만 사용됩니다. 그렇지 않으면 원래 제목이 표시됩니다.
다음 표는 캡션 제목을 지원하는 블록과 변환기가 이를 생성하고 제어하는 데 사용하는 속성을 나열합니다.
[cols="1,1,1", options="header"]
|===
|Block context |Caption attribute |Counter attribute
|appendix
|appendix-caption
|appendix-number
|example
|example-caption
|example-number
|image
|figure-caption
|figure-number
|listing, source
|listing-caption
|listing-number
|table
|table-caption
|table-number
|===
목록 및 소스 블록(listing-caption)에 대한 속성을 제외하고 모든 캡션 속성이 기본적으로 설정됩니다. 번호는 순차적이며 자동으로 계산되어 해당 카운터 속성에 저장됩니다.
다음과 같이 예제 블록에 제목을 추가했다고 가정해 보겠습니다:
.Block that supports captioned title
Block content
블록 제목은 다음과 같이 캡션 레이블과 번호와 함께 표시됩니다:
Example 1. Block that supports captioned title
Block content
example-caption 속성을 해제하면 캡션이 제목 앞에 추가되지 않습니다.
Block that supports captioned title
Block content
카운터 속성(예: example-number)을 사용하여 해당 컨텍스트로 첫 번째 블록의 시작 번호 또는 후속 발생에 대해 시퀀스에서 선택한 다음 번호에 영향을 줄 수 있습니다. 그러나 이 방법은 신중하게 사용해야 합니다.
캡션은 블록의 caption 속성을 사용하여 재정의할 수 있습니다. caption 속성의 값은 제목 앞의 공백을 포함하여 전체 캡션을 대체합니다.
다음은 블록에서 사용자 지정 캡션을 정의하는 방법입니다:
.Block Title
[caption="Example {counter:my-example-number:A}: "]
Block content
다음은 사용자 지정 캡션이 있는 블록이 표시되는 방식입니다:
Example A: Block Title
Block content
caption 속성의 값에 카운터 속성을 사용하여 사용자 지정 번호 시퀀스를 만들었습니다.
사용자 지정 캡션이 있는 블록을 xref를 사용하여 참조하는 경우 예상한 결과를 얻지 못할 수 있습니다. 따라서 사용자 지정 캡션을 정의할 때는 항상 사용자 지정 xreftext를 정의하는 것이 가장 좋습니다.

[[assign-id]]
== Blocks - Assign an ID

속성 목록을 사용하여 모든 블록에 ID를 할당할 수 있습니다. 블록에 ID를 할당하면 교차 참조를 사용하여 해당 ID를 사용해 링크할 수 있습니다.
=== 블록 ID 구문
ID 값 앞에 해시(#)를 접두사로 붙이고 블록의 속성 목록에 배치하여 블록에 ID가 할당됩니다.
[#the-id-of-this-block]
Content of delimited example block
여러 속성, 제목 및 구분 기호가 있는 블록에 ID를 할당하는 몇 가지 예를 살펴보겠습니다.
=== 속성이 있는 블록에 ID 할당
이 섹션에서는 다음 인용구에 ID를 할당하겠습니다:
Roads? Where we're going, we don't need roads.
— Dr. Emmett Brown Back to the Future
스타일 속성이 블록에 명시적으로 할당되면 스타일 이름은 항상 속성 목록의 첫 번째 위치에 배치됩니다. 그런 다음 ID는 스타일 이름의 끝에 직접 연결됩니다.
예제 1의 할당된 스타일과 ID가 있는 인용구는 이 속성 순서를 보여줍니다.
예제 1. 블록에 스타일과 ID 할당
[quote#roads]
Roads? Where we're going, we don't need roads.
예제 1은 인용구이므로 화자와 원래 맥락에 대한 정보가 있어야 합니다. 예제 2에서는 quote 스타일에 내장된 위치 기반 속성을 사용하여 이 인용구를 화자와 원래 맥락에 속성을 부여해 보겠습니다.
예제 2. 블록에 스타일, ID 및 위치 기반 속성 할당
[quote#roads,Dr. Emmett Brown,Back to the Future]
Roads? Where we're going, we don't need roads.
role과 options 속성에 각각 단축 구문(.과 %)을 사용하여 값을 할당하는 경우를 제외하고, 다른 모든 블록 속성은 일반적으로 쉼표(,)로 구분됩니다.


== Blocks - Block Masquerading
[[block-masquerading]]
선언된 블록 스타일(즉, 블록 속성 목록의 첫 번째 위치 기반 속성)은 모든 단락 및 대부분의 구조적 컨테이너의 컨텍스트를 수정하는 데 사용할 수 있습니다. 이 방법은 블록 마스커레이딩(한 블록을 다른 블록으로 위장하는 것을 의미)으로 알려져 있습니다.
선언된 블록 스타일을 사용하여 단락의 컨텍스트를 변경하면 블록은 단순한 콘텐츠 모델을 유지합니다. 구조적 컨테이너의 컨텍스트를 마스커레이딩할 때는 예상되는 콘텐츠 모델을 보존하는 컨텍스트만 허용됩니다.
=== 작동 방식
블록에 선언된 블록 스타일이 컨텍스트의 이름과 일치하면 블록의 컨텍스트를 해당 값으로 설정하고 해결된 블록 스타일은 설정되지 않은 상태로 남습니다. 선언된 블록 스타일이 컨텍스트의 이름과 일치하지 않으면 컨텍스트를 특수화하거나 컨텍스트를 암시적으로 설정하고 해당 컨텍스트도 특수화합니다. 사용자 지정 블록에 대해 선언된 블록 스타일이 처리되는 방식은 확장에 따라 다르지만 유사한 프로세스가 발생합니다.
선언된 블록 스타일을 사용하여 구조적 컨테이너의 컨텍스트를 변경하는 경우를 살펴보겠습니다. 이 경우 선언된 블록 스타일을 사용하여 리터럴 블록을 목록 블록으로 변경합니다.
[listing]
....
a > b
....
구조적 컨테이너의 기본 컨텍스트가 :literal이지만 선언된 블록 스타일은 이를 :listing으로 변경합니다. 블록의 해결된 블록 스타일은 설정되지 않은 상태로 유지됩니다.
선언된 블록 스타일은 단락을 다른 종류의 블록으로 변환하는 데에도 사용할 수 있습니다. 블록은 여전히 단순한 콘텐츠 모델을 유지합니다. 일반 단락을 사이드바로 바꾸는 경우를 살펴보겠습니다.
[sidebar]
This sidebar is short, so a styled paragraph will do.
마지막으로 경고 블록을 살펴보겠습니다. 예제 구조적 컨테이너에 NOTE 블록 스타일을 선언하면 경고 블록으로 변환되고 블록의 스타일도 NOTE로 설정됩니다.
[NOTE]
Remember the milk.
이 기술은 단락을 경고 블록으로 변환하는 데에도 사용할 수 있습니다.
[NOTE]
Remember the milk.
허용되는 경우 선언된 블록 스타일을 사용하여 블록의 컨텍스트를 특수화하거나 블록의 컨텍스트를 변경하거나 둘 다 수행할 수 있습니다.
=== 내장 순열
아래 표는 선언된 블록 스타일을 사용하여 컨텍스트를 변경할 수 있는 구조적 컨테이너와 유효한 컨텍스트를 나열합니다.
[cols="1,1,1", options="header"]
|===
|Type |Default context |Masquerading contexts
|example
|:example
|admonition (NOTE, TIP, WARNING, CAUTION 또는 IMPORTANT 스타일로 지정)
|listing
|:listing
|literal
|literal
|:literal
|listing (source 스타일을 사용하여 지정 가능)
|open
|:open
|abstract, admonition (NOTE, TIP, WARNING, CAUTION 또는 IMPORTANT 스타일로 지정), comment, example, literal, listing (source 스타일을 사용하여 지정 가능), partintro, pass, quote, sidebar, verse
|pass
|:pass
|stem, latexmath, asciimath
|sidebar
|:sidebar
|n/a
|quote
|:quote
|verse
|===
열린 블록에 적용할 수 있는 모든 컨텍스트는 단락에도 적용할 수 있습니다. 단락은 normal 스타일에도 액세스할 수 있으며, 이는 리터럴 단락을 일반 단락으로 되돌리는 데 사용할 수 있습니다.



== Blocks - Troubleshooting Blocks
[[troubleshooting-blocks]]
=== 열고 닫는 구분 기호
구분된 블록의 열고 닫는 구분 기호는 길이가 같아야 합니다. 예를 들어, 사이드바는 네 개의 별표(****)로 된 여는 구분 기호로 지정됩니다. 닫는 구분 기호도 네 개의 별표(****)여야 합니다.

다음은 유효한 구분 기호 길이를 사용하는 사이드바입니다:

This is a valid delimited block.
It will be styled as a sidebar.

그러나 다음 구분된 블록의 구분 기호 길이는 같지 않으므로 유효하지 않습니다:

This is an invalid sidebar block because the delimiter lines are different lengths.

AsciiDoc 프로세서가 이전 예제를 만나면 문서의 나머지 내용을 구분된 블록 안에 넣습니다. 프로세서에 관한 한 닫는 구분 기호는 내용의 한 줄일 뿐입니다. 그러나 일치하는 닫는 구분 기호가 발견되지 않으면 프로세서가 경고를 발행합니다.

프로세서가 닫는 구분 기호를 인식하게 하려면 여는 구분 기호와 길이가 같아야 합니다.

Copy
Retr



[[document-attributes]]
== Document Attributes

각 문서에는 문서 속성이라고 하는 이름-값 쌍 집합이 있습니다. 이러한 속성은 AsciiDoc 프로세서를 구성하고, 문서 메타데이터를 선언하며, 재사용 가능한 내용을 정의하는 수단을 제공합니다. 이 페이지에서는 문서 속성을 소개하고 이를 참조할 때 사용되는 용어에 대한 몇 가지 질문에 답합니다.

=== 문서 속성이란 무엇인가요?
문서 속성은 AsciiDoc 언어에 대한 문서 범위의 변수입니다. AsciiDoc 언어는 기본 제공 속성 집합을 정의하고, 작성자(또는 확장)가 허용될 때 기본 제공 속성을 대체할 수 있는 추가 문서 속성을 정의할 수 있도록 합니다.

기본 제공 속성은 문서 및 환경에 대한 읽기 전용 정보에 대한 액세스를 제공하거나 작성자가 전체 문서 또는 선택한 영역에 대해 AsciiDoc 프로세서의 동작을 구성할 수 있도록 합니다. 기본 제공 속성은 효과적으로 정렬되지 않습니다. 사용자 정의 속성은 강력한 텍스트 대체 도구 역할을 합니다. 사용자 정의 속성은 정의된 순서대로 저장됩니다.

다음은 문서 속성이 사용되는 몇 가지 사항에 대한 요약입니다:

- 문서 정보에 대한 액세스 제공
- 문서 메타데이터 정의
- 기본 제공 기능 켜기 또는 끄기
- 기본 제공 기능 구성
- 이미지와 같은 자산의 위치 선언
- 문서 전체에서 재사용할 내용 저장

다양한 유형의 문서 속성을 자세히 살펴보겠습니다.

=== 문서 속성의 유형

문서 속성은 다음 그룹으로 분류됩니다.

==== 기본 제공 속성

기본 제공 속성은 문서에서 일반적인 기능을 추가, 구성 및 제어합니다. 많은 기본 제공 속성은 문서 헤더의 속성 항목으로 정의된 경우에만 적용됩니다.

부울 속성은 기본 제공 속성의 하위 그룹입니다. 부울 속성이 정의되었지만 값이 주어지지 않은 경우(즉, 설정된 경우), "on" 상태입니다. 속성이 정의되지 않은 경우(즉, 설정되지 않은 경우), "off" 상태입니다. 이러한 측면에서 이러한 속성은 스위치 역할을 합니다. 이들의 유일한 기능은 기능을 켜거나 끄는 것입니다.

==== 사용자 정의 속성

사용자 정의 속성은 AsciiDoc 언어나 확장에서 예약되지 않은 작성자가 설정하는 모든 속성입니다. 대부분의 경우 사용자 정의 속성은 텍스트 대체 도구로 사용됩니다. 이러한 속성을 사용하면 작성자가 명명된 재사용 가능한 내용을 정의할 수 있습니다. 따라서 제품 이름과 같은 텍스트를 문서 전체에서 반복하는 대신 해당 텍스트를 속성으로 정의하고 대신 이름으로 참조할 수 있습니다. 이 기법은 문서를 DRY(반복하지 마세요)하게 유지하는 데 도움이 됩니다.

=== 속성을 정의한다는 것은 무엇을 의미하나요?

- 기본 제공 속성의 경우 기본값을 가집니다.
- 부울 속성 및 기본값이 있는 기본 제공 속성의 경우 값이 없습니다.
- 단일 행 값을 가집니다.
- 여러 연속 행에 걸쳐 있는 값을 가집니다.
- 다음과 같은 기본 인라인 AsciiDoc 구문을 포함하는 값을 가집니다:
  ** 속성 참조
  ** 텍스트 서식(pass 매크로로 래핑된 경우)
  ** 인라인 매크로(pass 매크로로 래핑된 경우)

그러나 알아야 할 특정 제한 사항이 있습니다. 문서 속성은 다음과 같은 AsciiDoc 블록 내용을 포함하는 값을 가질 수 없습니다:

- 목록
- 여러 단락
- 블록(테이블, 사이드바, 예제 등)
- 기타 공백에 의존하는 마크업

=== 문서 속성을 설정한다는 것은 무엇을 의미하나요?

설정(켜짐)됩니다.

=== 문서 속성을 설정 해제한다는 것은 무엇을 의미하나요?

이름 앞에 선행(선호) 또는 후행 !를 추가하여 설정 해제(꺼짐)합니다.

=== 문서 속성은 어디에서 정의, 설정 및 설정 해제되나요?

문서 속성은 다음에서 선언할 수 있습니다:

- 문서 헤더의 속성 항목
- 문서 본문의 속성 항목
- :attributes 옵션을 통한 API
- -a 옵션을 통한 CLI
- 명령줄에서 할당된 잠긴 속성 재정의

=== 문서 속성을 참조한다는 것은 무엇을 의미하나요?

문서 속성을 참조한다는 것은 속성 이름을 해당 속성의 값으로 대체하는 것을 의미합니다. 문서 속성은 문서에서 {name} 구문을 사용하여 참조할 수 있습니다. 여기서 name은 속성의 이름입니다.

=== 문서 속성은 어디에서 참조될 수 있나요?

문서 속성은 속성 대체가 적용되는 문서의 어디에서나 참조될 수 있습니다. 일반적으로 속성 대체는 속성 항목의 값, 제목, 단락 텍스트, 목록 텍스트, 요소 속성의 값 및 매크로의 대상에 적용됩니다.
문서 속성은 정의된 후에만 참조할 수 있습니다.

[[attribute-entries]]
== Document Attributes - Attribute Entries

=== 속성 항목이란 무엇인가요?

문서에서 문서 속성을 사용하려면 먼저 선언해야 합니다. 속성 항목은 AsciiDoc 문서에서 문서 속성을 정의하는 주요 메커니즘입니다. 속성 항목을 AsciiDoc의 전역 변수 할당으로 생각할 수 있습니다. 생성된 문서 속성은 문서의 해당 지점부터 사용할 수 있게 됩니다. 속성 항목은 또한 기능을 토글하는 데 자주 사용됩니다.

속성 항목은 속성 이름과 속성 값의 두 부분으로 구성됩니다. 속성 이름이 먼저 나오고 그 다음에 선택적 값이 나옵니다. 각 속성 항목은 자체 행에 입력해야 합니다. 속성 항목은 여는 콜론(:)으로 시작하고, 바로 뒤에 속성의 이름이 오고, 그 다음에 닫는 콜론(:)이 옵니다. 이렇게 하면 문서 속성이 설정되어(즉, 켜져) 문서에서 사용할 수 있습니다.

[source,asciidoc]
----
:name-of-an-attribute: [1]
----
[1] 속성의 이름 바로 앞에는 여는 콜론(:)이, 바로 뒤에는 닫는 콜론(:)이 옵니다.

대부분의 경우, 속성 항목에서 이름 뒤에 정보를 입력하여 문서 속성에 값을 명시적으로 할당합니다. 값은 닫는 콜론(:)과 최소한 하나의 공백으로 구분되어야 합니다.

[source,asciidoc]
----
:name-of-an-attribute: value of the attribute [1]
----
[1] 명시적으로 할당된 값은 닫는 콜론(:)과 최소한 하나의 공백으로 구분됩니다. 값의 끝에서 Enter를 누릅니다.

기본적으로 헤더 대체가 값에 자동으로 적용된다는 점에 유의하세요. 즉, HTML 태그와 같은 특수 문자를 이스케이프할 필요가 없습니다. 또한 속성의 값을 정의할 때 이미 정의된 속성의 값을 참조할 수 있습니다. 속성 항목 값의 속성 참조는 즉시 해결됩니다.

[source,asciidoc]
----
:url-org: https://example.org/projects
:url-project: {url-org}/project-name [1]
----
[1] 속성 참조를 사용하여 값에서 이미 설정된 속성의 값을 재사용할 수 있습니다.

일부 기본 제공 속성은 부울 속성이거나 암시적 값을 가지므로 속성 항목에서 값을 명시적으로 할당할 필요가 없습니다.

[source,asciidoc]
----
:name-of-an-attribute: [1]
----

[1] 속성에 값을 명시적으로 할당하지 않으려면 닫는 콜론(:) 뒤에서 Enter를 누릅니다.

설정되면 기본 제공 부울 속성의 값은 항상 비어 있습니다(즉, 빈 문자열). 기본 제공 속성을 설정하고 값을 비워 두면 AsciiDoc 프로세서가 처리 시점에 값을 유추할 수 있습니다.

=== 속성 항목은 어디에서 선언할 수 있나요?

속성 항목은 대개 문서 헤더에 선언됩니다. 허용하는 속성의 경우(범용 속성 포함), 속성 항목은 대신 문서 본문(즉, 헤더 아래의 문서 부분)의 블록 사이에 선언할 수 있습니다.

[WARNING]
====
속성 항목은 구분된 블록의 경계 내에서 선언하지 않아야 합니다. 속성 항목이 구분된 블록 내에서 선언되면 동작이 정의되지 않습니다.
====

속성 항목을 사용하여 문서 헤더에서 속성이 정의되면 헤더 속성이라고 합니다. 헤더 속성은 설정 해제될 때까지 전체 문서에서 사용할 수 있습니다. 헤더 속성은 기본 제공 동작, 확장 및 값을 참조해야 하는 기타 애플리케이션(예: source-highlighter)에서 사용하기 위해 문서 메타데이터에서도 액세스할 수 있습니다.

속성 항목을 사용하여 문서 본문에서 속성이 정의되면 단순히 문서 속성이라고 합니다. 본문에 정의된 모든 속성의 경우, 속성은 설정된 시점부터 설정 해제될 때까지 사용할 수 있습니다. 본문에 정의된 속성은 문서 메타데이터를 통해 사용할 수 없습니다.

속성이 잠겨 있지 않으면 문서 헤더나 본문에서 설정을 해제하거나 새 값을 할당할 수 있습니다. 그러나 문서 본문의 동작을 제어하는 헤더 속성을 설정 해제하거나 재정의해도 보통 영향을 미치지 않습니다. 문서의 어느 위치에서 각 속성을 설정할 수 있는지는 문서 속성 참조를 참조하세요.

=== 속성 항목 없이 문서 속성 정의하기

문서 속성은 CLI 및 API를 통해 문서 외부에서 선언할 수도 있습니다(선택적 값으로 설정 또는 설정 해제). 이러한 경우에는 속성 항목 구문이 사용되지 않습니다. 오히려 제공된 옵션을 사용하여 선언됩니다. API의 경우 :attributes 옵션을 사용하여 속성이 선언됩니다(다양한 항목 형식 지원). CLI의 경우 -a 옵션을 사용하여 속성이 선언됩니다.

속성에 문서 외부에서 값이 할당되면 값이 있는 그대로 저장됩니다. 즉, 대체가 적용되지 않습니다. 또한 문서에서 해당 속성을 참조할 때 특수 문자 및 따옴표 대체가 해당 속성의 값에 적용되지 않습니다. 그러나 매크로 대체와 같은 후속 대체는 적용됩니다. 이 동작은 특수 문자 및 따옴표 대체 후에 속성 대체가 적용된다는 사실 때문입니다. 이러한 대체가 속성의 값에 적용되도록 하려면 참조 시점에 대체 순서를 변경해야 합니다. 다음은 인라인 pass 매크로를 사용한 예입니다.

[source,asciidoc]
----
pass:a,q[{attribute-with-formatted-text}]
----

속성이 명령줄이나 API에서 선언되면 암시적으로 문서 헤더 속성이 됩니다. 기본적으로 속성은 잠기게 되어(즉, 하드 설정 또는 설정 해제됨) 문서에 의해 변경될 수 없습니다. 이 동작은 속성 이름이나 값 끝에 @를 추가하여 변경할 수 있습니다(즉, 소프트 설정 수정자). 자세한 내용은 문서 속성 할당 우선순위를 참조하세요.

이 규칙의 유일한 예외는 항상 변경할 수 있는 sectnums 속성입니다.



[[attribute-entry-names-and-values]]
== Document Attributes - Reference Attributes - Attribute Entry Names and Values

=== 유효한 내장 이름

내장 속성 이름은 예약되어 있으며 사용자 정의 속성 이름으로 다시 사용할 수 없습니다. 내장 속성 이름은 문서 속성 참조 및 문자 대체 속성 참조에 나열되어 있습니다.

=== 유효한 사용자 정의 이름

사용자 정의 속성 이름은 다음과 같아야 합니다:

- 길이가 최소 한 글자 이상이어야 합니다.
- 단어 문자(a-z, 0-9 또는 _)로 시작해야 합니다.
- 단어 문자와 하이픈(-)만 포함해야 합니다.

사용자 정의 속성 이름에는 점(.)이나 공백이 포함될 수 없습니다. 속성 이름에 대문자를 사용할 수 있지만, 문서가 로드되거나 변환될 때 이름은 소문자로 변환된 후 저장됩니다. 예를 들어, URL-REPO와 URL-Repo는 문서가 로드되거나 변환될 때 url-repo로 처리됩니다. 모범 사례는 이름에 소문자만 사용하고 숫자로 시작하지 않는 것입니다.

=== 속성 값 유형 및 할당 방법

속성에 따라 값은 빈 문자열, 5나 2와 같은 정수 또는 이름이나 URL과 같은 문자열일 수 있습니다. 문자열 값을 허용하는 속성에는 다른 속성 및 인라인 매크로에 대한 참조가 포함될 수 있습니다. 값에는 표나 사이드바와 같은 복잡한 다중 행 블록 요소가 포함될 수 없습니다.

속성 값은 속성 항목에서 값을 비워 두거나 사용자가 명시적으로 값을 할당할 때 기본값으로 할당될 수 있습니다. 속성이 허용하는 값의 유형과 기본값을 사용하는지, 여러 내장 값을 가지는지, 사용자 정의 값을 허용하는지 또는 값을 명시적으로 할당해야 하는지는 속성에 따라 다릅니다.

==== 내장 값

많은 내장 속성에는 하나 이상의 내장 값이 있습니다. 이러한 값 중 하나는 속성의 기본값으로 지정될 수 있습니다. 속성을 설정하고 값을 비워 두면 AsciiDoc 프로세서가 이 기본값으로 대체합니다. 또한 프로세서는 처리 시 자동으로 수많은 내장 속성을 설정하고 속성을 명시적으로 해제하거나 다른 값을 할당하지 않는 한 기본값을 할당합니다. 예를 들어, 프로세서는 모든 문자 대체 속성을 자동으로 설정합니다.
내장 속성의 기본값이 아닌 값을 사용하려면 해당 값을 설정하고 대체 값을 할당해야 합니다.

==== 빈 문자열 값

내장 부울 속성의 값은 이러한 속성이 기능을 켜거나 끄는 데만 사용되므로 항상 속성 항목에서 비워 둡니다. 처리 중에 AsciiDoc 프로세서는 활성화된 모든 부울 속성에 빈 문자열 값을 할당합니다.

==== 명시적 값

다음과 같은 경우 속성에 값을 명시적으로 할당해야 합니다:

- 기본값이 없는 경우
- 기본값을 재정의하려는 경우
- 사용자 정의 속성인 경우

내장 속성이 허용하는 명시적 값의 유형은 속성에 따라 다릅니다. 사용자 정의 속성은 문자열 값을 허용합니다. 긴 명시적 값은 줄 바꿈할 수 있습니다.



[[wrap-attribute-entry-values]]
== Document Attributes - Reference Attributes - Wrap Attribute Entry Values

=== 속성 값 소프트 줄 바꿈

문서 속성의 값이 화면에 맞추기에 너무 길면 읽기 쉽도록 행 연속(line continuation)을 사용하여 값을 여러 줄로 나눌 수 있습니다.

행 연속은 줄 끝에 공백과 백슬래시 문자(\)로 구성됩니다. 행 연속은 마지막 줄을 제외한 다중 행 값의 모든 줄에 배치되어야 합니다. 행 연속 문자 뒤에 오는 줄은 들여쓰기할 수 있지만 해당 들여쓰기는 값에 포함되지 않습니다.

프로세서가 속성 값을 읽을 때 행 연속, 줄 바꿈 및 후속 들여쓰기를 단일 공백으로 접습니다. 이 경우 속성 값에 소프트 줄 바꿈이 있다고 말할 수 있습니다.

description이라는 이름의 속성을 정의하고 매우 긴 값을 가지고 있다고 가정해 보겠습니다. 마지막을 제외한 값의 각 줄 끝에 행 연속을 배치하여 이 속성을 여러 줄로 분할할 수 있습니다.

.예제 1. 소프트 줄 바꿈이 있는 다중 행 속성 값

[source,asciidoc]
----
:description: If you have a very long line of text \
that you need to substitute regularly in a document, \
you may find it easier to split the value neatly in the header \
so it remains readable to folks looking at the AsciiDoc source.
----

행 연속이 누락된 경우 프로세서는 값의 끝을 찾은 것으로 가정하고 후속 줄을 속성 값에 포함하지 않습니다.

=== 속성 값 하드 줄 바꿈

행 연속 앞에 하드 줄 바꿈 대체(hard line break replacement)를 삽입하여 속성 값을 강제로 하드 줄 바꿈할 수 있습니다. 하드 줄 바꿈 대체는 공백 뒤에 더하기 문자(+)가 옵니다.
이전 섹션에서 설명한 대로 행 연속, 줄 바꿈 및 후속 들여쓰기는 일반적으로 공백으로 대체됩니다. 이렇게 하면 하드 줄 바꿈 대체가 인식되지 않습니다. 그러나 프로세서는 이 시나리오를 고려하고 줄 바꿈을 그대로 유지합니다.

하드 줄 바꿈이 필요한 haiku라는 이름의 속성을 정의한다고 가정해 보겠습니다. 마지막을 제외한 값의 각 줄 끝에 하드 줄 바꿈 대체와 행 연속을 배치하여 이 속성을 여러 줄로 분할하고 해당 줄 바꿈을 유지할 수 있습니다.

.예제 2. 하드 줄 바꿈이 있는 다중 행 속성 값
[source,asciidoc]
----
:haiku: Write your docs in text, + 
AsciiDoc makes it easy, + 
Now get back to work!
----

이 구문은 출력에서 줄 바꿈이 하드 줄 바꿈으로 유지되도록 합니다.



[[attribute-entry-substitutions]]
== Document Attributes - Reference Attributes - Attribute Entry Substitutions

AsciiDoc 프로세서는 속성 항목의 값이 문서의 어디에 선언되어 있는지에 관계없이 할당 전에 헤더 치환 그룹의 치환을 자동으로 적용합니다. 속성 참조 뒤에 오는 특수 문자를 대체하는 헤더 치환 그룹은 속성 항목이 헤더에 정의되어 있는지 또는 문서 본문에 정의되어 있는지에 관계없이 속성 항목의 값에 적용됩니다. 이것은 문서 헤더의 메타데이터 줄(작성자 및 개정 정보)에 적용되는 것과 동일한 그룹입니다.
즉, 속성 값에 있는 모든 인라인 형식은 다음과 같은 이유로 해석되지 않습니다:

- AsciiDoc 프로세서가 속성을 설정할 때 인라인 형식이 적용되지 않습니다.
- 관련 치환이 속성이 해결되기 전에 발생하므로 속성이 참조될 때 인라인 형식이 적용되지 않습니다.

=== 값을 할당할 때 치환 변경

속성 항목의 값을 있는 그대로 사용하려는 경우(치환 대상이 아님) 또는 적용되는 치환을 변경하려는 경우 값을 인라인 pass 매크로(즉, `\pass:[]`)로 묶을 수 있습니다. 인라인 pass 매크로는 대상 슬롯에 0개 이상의 치환 목록을 허용하며, 이를 사용하여 값에 적용되는 치환을 제어할 수 있습니다. 치환을 지정하지 않으면 치환이 적용되지 않습니다.

이 컨텍스트에서 인라인 매크로가 작동하려면 속성 값을 완전히 둘러싸야 합니다. 값의 다른 곳에 사용되면 무시됩니다.

속성 항목의 값에 치환이 적용되지 않도록 하는 방법은 다음과 같습니다:
[source,asciidoc]
----
:cols: pass:[.>2,.>4]
----

이것은 cols 속성의 값과 같이 변경되지 않은 텍스트에 의존하는 곳에서 속성을 참조하는 경우에 유용할 수 있습니다.

속성 항목의 값에 인용 치환을 적용하는 방법은 다음과 같습니다:
[source,asciidoc]
----
:app-name: pass:quotes[MyApp^2^]
----

내부적으로 값은 MyApp<sup>2</sup>로 저장됩니다. 다음과 같은 방법으로 속성에 저장된 값을 검사할 수 있습니다:
[source,asciidoc]
----
[subs=attributes+]
------
{app-name}
------
----

단일 문자 별칭 q를 사용하여 치환을 지정할 수도 있습니다.
[source,asciidoc]
----
:app-name: pass:q[MyApp^2^]
----

인라인 pass 매크로는 일종의 속성 값 전처리기처럼 작동합니다. 프로세서가 인라인 pass 매크로가 속성 값을 완전히 둘러싸고 있음을 감지하면 다음을 수행합니다:

1. 매크로의 대상 슬롯에서 치환 목록을 읽습니다.
2. 매크로에서 값을 풉니다.
3. 값에 치환을 적용합니다.

매크로가 없으면 값은 헤더 치환 그룹으로 처리됩니다.

=== 문서 외부에서 정의된 속성에 대한 치환

속성 항목과 달리 AsciiDoc 프로세서에 전달된 속성의 값에는 치환이 적용되지 않습니다. -a CLI 옵션 또는 :attributes API 옵션을 사용하여 AsciiDoc 프로세서에 속성을 전달할 수 있습니다. 속성이 문서 외부에서 정의되면 값은 그대로 참조할 준비가 되어 있어야 합니다. 값에 XML 특수 문자가 포함된 경우 해당 문자를 미리 이스케이프해야 합니다. 값에 XML/HTML 태그를 보존하려는 경우는 예외입니다. 값이 다른 속성을 참조해야 하는 경우 해당 값을 미리 대체해야 합니다.

문서 외부에 정의된 속성의 값에 앰퍼샌드(&)가 포함된 경우를 고려해 보겠습니다. AsciiDoc 문서에서 이 속성을 안전하게 참조하려면 앰퍼샌드를 이스케이프해야 합니다:

[source,bash]
----
asciidoctor -a equipment="a bat &amp; ball" document.adoc
----

다음과 같이 속성을 참조할 수 있습니다:

[source,asciidoc]
----
To play, you'll need {equipment}.
----

속성이 문서에 정의되어 있는 경우 이러한 이스케이프는 필요하지 않습니다.

[source,asciidoc]
----
:equipment: a bat & ball
----

그 이유는 대조적으로 속성 항목의 값에는 치환이 적용되기 때문입니다.

=== 속성을 참조할 때 치환 변경

속성이 참조될 때 적용되는 치환을 변경할 수도 있습니다. 이는 참조되는 위치의 텍스트에 적용되는 치환을 조작하여 수행됩니다. 예를 들어, 다음은 프로세서가 속성 값에 인용 치환을 적용하도록 하는 방법입니다:
[source,asciidoc]
----
:app-name: MyApp^2^

[subs="specialchars,attributes,quotes,replacements,macros,post_replacements"]
The application is called {app-name}.
----

attributes와 quotes 치환의 순서를 바꾼 것에 주목하세요. 이 전략은 속성 값을 후처리하는 것과 유사합니다.



[[inline-attribute-entries]]
== Document Attributes - Reference Attributes - Inline Attribute Entries

=== 인라인 속성 항목
속성 참조는 전용 속성 항목 라인의 대안으로 속성을 인라인으로 설정하거나 해제하는 데 사용할 수 있습니다. 이 메커니즘을 사용하면 일반 테이블 셀이나 목록 항목과 같이 속성 항목 라인이 허용되지 않는 곳에서 속성을 설정하거나 해제할 수 있습니다.
속성은 다음 표기법을 사용하여 인라인으로 정의할 수 있습니다:
{set:name:value}
값 부분은 선택 사항입니다. 값이 없으면 기본값은 빈 문자열입니다. 이 경우 표기법은 다음과 같이 축소됩니다:
{set:name}
대신 속성을 해제하려면 이름 뒤에 ! 문자를 추가합니다:
{set:name!}
다음은 인라인 속성 항목을 사용하여 sourcedir 속성을 src/main/java 값으로 설정하는 예입니다.
{set:sourcedir:src/main/java}
이 할당은 다음과 효과적으로 동일합니다:
:sourcedir: src/main/java
그러나 인라인 속성 할당은 속성 항목 라인과 다른 단계에서 처리된다는 점을 이해하는 것이 중요합니다. 인라인 속성 항목은 속성 치환의 일부로 속성 참조가 대체될 때 처리됩니다. 따라서 할당 결과는 그 뒤에 오는 속성 참조에서만 사용할 수 있습니다. 이러한 할당은 문서가 로드된 후 문서 모델에서 보이지 않습니다.
인라인 속성 항목의 제한 사항을 이해하거나 사용 사례를 충족하기 위한 최후의 수단이 아닌 한 사용하지 않는 것이 좋습니다.



[[declare-built-in-attributes]]
== Document Attributes - Declare Built-In Attributes
AsciiDoc 프로세서에는 특별한 용도로 예약된 많은 속성이 있습니다. 내장 속성은 문서의 공통 기능을 추가, 구성 및 제어합니다. 많은 내장 속성은 문서 헤더에서 속성 항목으로 정의된 경우에만 적용됩니다.
=== 속성의 기본값 사용
많은 내장 속성에는 기본값이 있습니다. 내장 속성을 활성화하고 기본값을 할당하려면 속성 항목의 값을 비워 둘 수 있습니다.
예를 들어, 문서의 목차를 활성화하려면 문서 헤더에서 속성 항목을 사용하여 toc 속성을 설정합니다.
= Title of Document
:toc:
다음과 같은 경우 처리 시 활성화된 속성의 기본값이 할당됩니다:

기본값이 있고,
속성 항목의 값이 비어 있는 경우

위의 예에서 속성 항목의 값이 비어 있으므로 toc에 auto의 기본값이 할당됩니다.
=== 속성의 기본값 재정의
내장 속성의 기본값을 사용하지 않을 수 있습니다. 다음 예에서는 AsciiDoc 프로세서가 자동으로 설정하는 속성의 기본값을 재정의하겠습니다. 내장 속성 doctype은 처리 시 자동으로 설정되고 article 값이 할당됩니다. 그러나 AsciiDoc의 책 기능을 사용하려면 doctype 속성에 book 값을 할당해야 합니다.
= Title of My Document
:doctype: book
문서 헤더에서 doctype을 설정하고 book 값을 할당합니다. 명시적 값은 닫는 콜론(:)에서 최소한 한 칸 이상 떨어져 있어야 합니다.
속성의 기본값을 재정의하려면 속성을 설정할 때 명시적으로 값을 할당해야 합니다. 문서 헤더에서 속성에 할당된 값은 기본값을 대체합니다(속성이 CLI 또는 API를 통해 잠기지 않았다고 가정).
=== 기본 자산 디렉터리 값 재정의
내장 자산 디렉터리 속성을 사용하여 이미지(기본값: empty), 아이콘(기본값: ./images/icons), 스타일시트(기본값: ./stylesheets) 및 JavaScript 파일(기본값: ./javascripts)의 기본 경로를 사용자 정의할 수도 있습니다.
예제 1. 내장 자산 디렉터리 속성의 기본값 대체
= My Document
:imagesdir: ./images
:iconsdir: ./icons
:stylesdir: ./styles
:scriptsdir: ./js
위 예제의 네 가지 내장 속성에는 처리 시 자동으로 설정되는 기본값이 있습니다. 그러나 예제에서는 문서 헤더에서 설정되고 명시적 값이 할당됩니다. 이 명시적 사용자 정의 값은 기본값을 대체합니다(속성이 CLI 또는 API를 통해 잠기지 않았다고 가정).



[[set-boolean-attributes]]
== Document Attributes - Reference Attributes - Set Boolean Attributes

부울 속성은 토글과 같은 역할을 하는 내장 속성입니다. 그 유일한 기능은 기능이나 동작을 켜는 것입니다.
=== 부울 속성 항목 구문
부울 속성은 문서의 헤더나 본문에서 속성 항목을 사용하여 설정됩니다. 부울 값의 값은 AsciiDoc의 부울 속성이 빈 문자열 값만 허용하므로 항상 비어 있습니다. AsciiDoc에서 설정되었지만 값이 비어 있는 속성은 true 상태로 해석되고 설정되지 않은 속성은 false 상태로 해석됩니다. 그러나 프로세서는 true 값을 true 상태로 해석할 수도 있습니다.
:name-of-a-boolean-attribute:
새 줄에서 콜론(:)을 입력한 다음, 속성 이름과 또 다른 콜론(:)을 차례로 입력합니다. 닫는 콜론 뒤에 Enter 키를 누릅니다. 이제 속성이 설정되고 해당 동작이 문서에 적용됩니다.
=== 부울 속성 선언
속성 항목을 사용하여 sectanchors라는 내장 부울 속성을 켜보겠습니다. sectanchors가 설정되면 커서가 섹션 제목 위로 지나갈 때 섹션 제목 앞에 앵커가 활성화됩니다.
= Document Title
:sectanchors:
sectanchors는 부울 속성이므로 값은 항상 비워 둡니다.



[[declare-custom-attributes]]
== Document Attributes - Declare Custom Attributes
동일한 텍스트를 반복해서 입력하거나 자주 업데이트해야 하는 텍스트가 있는 경우 자신만의 속성을 만드는 것이 좋습니다.
=== 사용자 정의 속성 이름과 값
사용자 정의 속성에는 이름과 명시적으로 할당된 값이 있어야 합니다.
속성의 이름은 다음과 같아야 합니다:

길이가 최소 한 글자 이상이어야 합니다.
단어 문자(A-Z, a-z, 0-9 또는 _)로 시작해야 합니다.
단어 문자와 하이픈만 포함해야 합니다.

이름에는 점이나 공백이 포함될 수 없습니다.
속성 이름에 대문자를 사용할 수 있지만, 저장되기 전에 이름은 소문자로 변환됩니다. 예를 들어, URL과 Url은 url로 처리됩니다. 모범 사례는 이름에 소문자만 사용하고 숫자로 시작하지 않는 것입니다.
속성 값은 다음과 같습니다:

모든 인라인 콘텐츠가 될 수 있습니다.
명시적 행 연속(+)이 사용되는 경우에만 줄 바꿈을 포함할 수 있습니다.

=== 사용자 정의 속성과 값 만들기
속성 항목의 주요 사용 사례는 자주 사용되는 텍스트와 URL을 문서 상단으로 승격하는 것입니다.
예제 1. 사용자 정의 속성과 값 만들기
:disclaimer: Don't pet the wild Wolpertingers. If you let them into your system, we're 
not responsible for any loss of hair, chocolate, or purple socks.
:url-repo: https://github.com/asciidoctor/asciidoctor
백슬래시(\)를 사용하여 긴 값을 소프트 줄 바꿈할 수 있습니다.
이제 문서 전체에서 이러한 속성을 참조할 수 있습니다.



[[unset-attributes]]
== Document Attributes - Unset Attributes
문서 속성(내장, 부울 및 사용자 정의)은 문서 헤더와 문서 본문에서 해제할 수 있습니다.
=== 헤더에서 문서 속성 해제
문서 속성은 속성 이름 바로 앞(선호) 또는 뒤에 느낌표 기호(!)를 추가하여 해제합니다. 문서 헤더에서 속성을 설정할 때와 마찬가지로 속성 항목은 자체 줄에 있어야 합니다. 항목에 값을 추가하지 마세요.
= Title
:!name:
:name!:
속성 이름 앞에 !이 붙으면 속성이 해제됩니다(선호).
속성 이름 뒤에 !이 붙으면 속성이 해제됩니다.
속성 항목을 사용하여 sectids라는 내장 부울 속성을 끄겠습니다. AsciiDoc 프로세서는 사용자가 해제하지 않는 한 처리 시 sectids를 자동으로 설정합니다. sectids 속성은 섹션의 제목에서 각 섹션에 대한 ID를 생성합니다.
예제 1. 부울 속성 해제
= Document Title
:!sectids:
새 줄에서 콜론(:)을 입력한 다음, 느낌표 기호(!), 속성 이름, 그리고 또 다른 콜론(:)을 차례로 입력합니다. 닫는 콜론 뒤에 Enter 키를 누릅니다. 이제 속성이 해제되고 해당 동작이 문서에 적용되지 않습니다.
속성이 해제되면 해당 동작이 비활성화됩니다. sectids가 해제되면 AsciiDoc 프로세서는 처리 시 섹션 제목에서 ID를 생성하지 않습니다.
예제 블록을 사용할 때 AsciiDoc 프로세서에 의해 자동으로 설정되고 Example의 기본값이 할당되는 내장 속성 example-caption을 해제해 보겠습니다.
예제 2. 자동으로 선언된 속성 해제
= Title
:!example-caption:
예제 블록의 동작을 제어하는 속성이 선행 !로 해제되었기 때문에 예제 블록에는 Example 1과 같은 레이블이 붙거나 번호가 매겨지지 않습니다.
=== 본문에서 문서 속성 해제
사용자 정의 문서 속성과 일부 내장 문서 속성은 이전 섹션에서 설명한 대로 속성 항목과 느낌표 기호(!)를 사용하여 문서 본문에서 끌 수 있습니다. 예를 들어, 문서 헤더에 섹션 번호 매기기 속성을 설정했지만 문서 중간에 있는 두 섹션에는 번호를 매기고 싶지 않다고 가정해 보겠습니다. 이 두 섹션의 번호 매기기를 비활성화하려면 번호를 매기고 싶지 않은 첫 번째 섹션 앞에서 sectnums를 해제한 다음 번호 매기기를 다시 시작하려는 시점에 다시 설정하면 됩니다.
= Title
:sectnums:
== Section Title
:!sectnums:
== Section Title
=== Section Title
:sectnums:
== Section Title
sectnums 속성은 문서 전체에서 섹션 번호 매기기를 활성화하기 위해 헤더에 설정됩니다.
sectnums는 속성 이름에 !를 추가하여 해제됩니다. !는 속성 이름 앞이나 뒤에 배치할 수 있습니다. 속성 항목은 자체 줄에 배치해야 합니다. 속성이 해제된 아래의 모든 섹션에는 번호가 매겨지지 않습니다.
sectnums가 설정되면 이후의 모든 섹션에 번호가 매겨집니다.



[[reference-attributes]]
== Document Attributes - Reference Attributes
문서 전체에서 사용자 정의 또는 내장 문서 속성의 값을 다양한 위치에 삽입하려고 할 것입니다. 삽입할 문서 속성을 참조하려면 속성의 이름을 중괄호로 묶습니다(예: {name-of-attribute}). 이 인라인 요소를 속성 참조라고 합니다. AsciiDoc 프로세서는 속성 참조를 속성의 값으로 바꿉니다. 이 대체를 방지하려면 요소 앞에 백슬래시를 접두사로 붙일 수 있습니다(예: {name-of-attribute}).
=== 사용자 정의 속성 참조
문서에서 사용자 정의(즉, 사용자 정의) 속성을 참조하려면 먼저 문서 헤더의 속성 항목을 사용하여 선언해야 합니다. 예제 1에서는 나중에 참조할 수 있는 두 개의 사용자 정의 속성을 선언합니다.
예제 1. 문서 헤더에 설정된 사용자 정의 속성
= Ops Manual
:disclaimer: Don't pet the wild Wolpertingers. We're not responsible for any loss of hair, chocolate, or purple socks.
:url-repo: https://github.com/asciidoctor/asciidoctor
문서 속성을 설정하고 값을 할당하면 문서 전체에서 해당 속성을 참조할 수 있습니다. 예제 2에서는 url-repo 속성이 두 번 참조되고 disclaimer가 한 번 참조됩니다.
예제 2. 문서 본문에서 참조되는 사용자 정의 속성
Asciidoctor is {url-repo}[open source].
WARNING: {disclaimer}
If you're missing a lime colored sock, file a ticket in
the {url-repo}/issues[Asciidoctor issue tracker].
(Actually, please don't).
속성 참조는 매크로에서 사용할 수 있습니다.
속성 참조는 경고와 같은 블록과 인라인에서 사용할 수 있습니다. disclaimer 참조와 다음 문장 사이에 빈 줄이 없으므로 문서가 처리될 때 문장이 속성 값의 끝에 직접 추가됩니다.
url-repo 속성에 대한 참조는 전체 URL 주소를 작성하기 위해 삽입되며, 이는 URL 매크로로 해석됩니다.
아래에서 볼 수 있듯이 문서가 처리될 때 속성 참조는 해당 속성 값으로 대체됩니다.
Asciidoctor is open source.
Don't pet the wild Wolpertingers. We're not responsible for any loss of hair, chocolate, or purple socks. If you're missing a lime colored sock, file a ticket in the Asciidoctor issue tracker. Actually, please don't.
=== 내장 속성 참조
내장 문서 속성(즉, 프로세서에 의해 자동으로 설정되는 문서 속성)은 사용자 정의(즉, 사용자 정의) 문서 속성과 동일한 방식으로 참조됩니다. 예를 들어, AsciiDoc 프로세서는 지원되는 문자 대체 속성을 자동으로 설정합니다. 즉, 헤더에 속성 항목을 만들 필요 없이 문서 전체에서 이러한 속성을 참조할 수 있습니다.
TIP: Wolpertingers don't like temperatures above 100{deg}C.
Our servers don't like them either.
문자 대체 속성 deg를 참조하려면 속성 이름을 중괄호 한 쌍({ 및 })으로 묶습니다.
아래에서 볼 수 있듯이 문서가 처리될 때 속성 참조는 속성의 값으로 대체됩니다.
Wolpertingers don't like temperatures above 100°C. Our servers don't like them either.
=== 속성 참조 이스케이프
콘텐츠에서 AsciiDoc 속성 참조의 구문과 일치하지만 실제로는 AsciiDoc 속성 참조가 아닌 문자 시퀀스가 발생하는 상황이 있을 수 있습니다. 예를 들어, 경로 템플릿을 문서화하는 경우 중괄호로 묶인 URL 경로의 대체 가능한 섹션을 참조해야 할 수 있습니다(예: /items/{id}). 이 경우 AsciiDoc 프로세서가 속성 참조를 건너뛰도록 속성 참조를 이스케이프하는 방법이 필요합니다. 그렇지 않으면 프로세서가 누락된 속성 참조에 대해 경고하거나 예기치 않은 대체를 수행할 수 있습니다. AsciiDoc는 속성 참조를 이스케이프하는 여러 가지 방법을 제공합니다.
=== 백슬래시 접두사
백슬래시를 접두사로 붙여 속성 참조를 이스케이프할 수 있습니다. 프로세서가 이 구문을 만나면 백슬래시를 제거하고 작성된 대로 속성 참조처럼 보이는 나머지 부분을 전달합니다.
예제 3에서는 백슬래시를 사용하여 속성 참조를 이스케이프합니다.
예제 3. 백슬래시를 사용하여 이스케이프된 속성 참조
In the path /items/{id}, id is a path parameter.
예제 3의 출력에서 경로의 {id} 표현식이 보존되는 것을 볼 수 있습니다.
In the path /items/{id}, id is a path parameter.
백슬래시는 중괄호 사이의 텍스트가 유효한 속성 이름인 경우에만 인식된다는 점에 유의하세요. 백슬래시 뒤의 구문이 속성 참조와 일치하지 않으면 처리 중에 백슬래시가 제거되지 않습니다.
=== 패스스루에 묶기
인라인 패스스루에 묶어 속성 참조를 이스케이프할 수도 있습니다. 이 경우 프로세서는 선택한 패스스루 유형에 대한 일반적인 대체 규칙을 사용합니다.
예제 4에서는 인라인 패스스루에 묶어 속성 참조를 이스케이프합니다.
예제 4. 인라인 패스스루에 묶어 이스케이프된 속성 참조
In the path +/items/{id}+, id is a path parameter.
예제 4의 출력에서 경로의 {id} 표현식이 보존되는 것을 볼 수 있습니다.
In the path /items/{id}, id is a path parameter.
인라인 패스스루를 사용할 때는 중괄호가 속성 참조를 형성하는지 여부를 걱정할 필요가 없습니다. 패스스루 묶음 사이의 모든 텍스트는 출력으로 전달됩니다.
=== 대체 이스케이프 메커니즘
속성 참조는 속성 대체로 대체됩니다. 따라서 대체를 제어할 수 있는 곳이라면 어디서든 속성 참조가 대체되는 것을 방지할 수 있습니다. 여기에는 인라인 pass 매크로와 블록의 subs 속성이 포함됩니다. 자세한 내용은 대체를 방지하기 위해 패스스루 사용을 참조하세요.



[[handle-unresolved-references]]
== Document Attributes - Reference Attributes - Handle Unresolved References
누락된 속성(예: {does-not-exist})을 참조하면 AsciiDoc 프로세서가 속성 참조를 그대로 남겨둡니다. 다른 텍스트와 같은 줄에서 속성을 정의하지 않으면(예: {set:attribute-no-more!}) 프로세서가 전체 줄을 삭제합니다. attribute-missing 및 attribute-undefined 속성을 사용하여 이러한 동작을 조정할 수 있습니다. 프로세서가 이러한 상황을 처리하는 방법을 고려하고 그에 따라 프로세서를 구성해야 합니다.
=== 누락된 속성
attribute-missing 속성은 누락된 참조가 처리되는 방식을 제어합니다. 기본적으로 누락된 참조는 문서의 무결성이 유지되고 작성자가 쉽게 추적할 수 있도록 그대로 남겨둡니다.
이 속성에는 네 가지 가능한 값이 있습니다:

skip: 참조를 그대로 둡니다(기본 설정).
drop: 참조는 삭제하지만 줄은 삭제하지 않습니다.
drop-line: 참조가 발생하는 줄을 삭제합니다(AsciiDoc.py의 동작과 일치).
warn: 누락된 속성에 대한 경고를 출력합니다.

가장 관심이 있을 수 있는 설정은 warn입니다. 프로세서가 해결할 수 없는 속성 참조를 만날 때마다 경고를 제공하지만 줄은 그대로 둡니다.
다음 줄을 고려해 보세요:
Hello, {name}!
name 속성이 정의되지 않았다고 가정하면, 각 경우에 따라 줄이 처리되는 방식은 다음과 같습니다:
[cols="1,1"]
|===
|attribute-missing 값 |결과
|skip
|Hello, {name}!
|drop
|Hello, !
|drop-line
|
|warn
|asciidoctor: WARNING: skipping reference to missing attribute: XYZ
|===
=== 기록
AsciiDoc.py는 항상 누락된 속성에 대한 참조가 포함된 줄을 삭제합니다(attribute-missing=drop-line과 동일한 효과). 이 "기능"은 프로세서가 구현된 방식의 부작용이었으며 작성자를 고려하여 설계된 것이 아닙니다. 이 동작은 발생 위치를 감지하기 어렵고 중요한 내용이 손실될 수 있기 때문에 작성자에게 불편합니다. 그래서 Asciidoctor는 다른 기본 동작을 사용하고 더 나아가 동작을 사용자 정의할 수 있게 합니다.
attribute-missing 속성이 엄격하게 준수되지 않는 몇 가지 경우가 있습니다. 그 중 하나는 include 지시문입니다. include 지시문의 대상에서 누락된 속성이 발견되면 프로세서는 누락된 속성에 대한 경고를 발행하고 변환된 문서에 동일한 경고 메시지를 남깁니다.
또 다른 경우는 ifeval 지시문입니다. 누락된 속성 참조는 해당 문의 목적이 속성이 값으로 해결되는지 여부를 결정하는 것이므로 ifeval 지시문의 절에서 부작용 없이(즉, 삭제 없이) 안전하게 사용할 수 있습니다.
=== 실패 강제
문서에 누락된 속성이 포함된 경우 프로세서가 실패하도록 하려면 attribute-missing 속성을 warn으로 설정하고 CLI에 --failure-level=WARN 옵션을 전달합니다.
asciidoctor -a attribute-missing=warn --failure-level=WARN doc.adoc
프로세서는 전체 문서를 변환하지만 애플리케이션은 0이 아닌 종료 상태로 완료됩니다.
API를 사용할 때는 보고된 모든 메시지의 최대 심각도에 대해 로거를 참조하거나 스택에서 특정 메시지를 찾을 수 있습니다. 애플리케이션을 종료하는 방법과 시기는 애플리케이션 코드에 달려 있습니다.
=== 정의되지 않은 속성
attribute-undefined 속성은 속성을 정의하지 않는 표현식(예: {set:name!})이 처리되는 방식을 제어합니다. 기본적으로 표현식이 내용 참조가 아니라 문으로 의도되었기 때문에 표현식이 포함된 줄이 삭제됩니다.
이 속성에는 두 가지 가능한 값이 있습니다:

drop: 처리 후 빈 문자열로 표현식을 대체합니다.
drop-line: 이 표현식이 포함된 줄을 삭제합니다(기본 설정, AsciiDoc.py의 동작과 일치).

여기서는 skip 옵션이 의미가 없습니다. 문이 내용을 생성하기 위한 것이 아니기 때문입니다.
다음 선언을 고려해 보세요:
{set:name!}
attribute-undefined가 drop인지 drop-line인지에 따라 문 또는 문이 포함된 줄이 삭제됩니다. 이 경우에는 호환되는 동작인 drop-line을 고수하는 것이 합리적입니다.
속성을 정의하지 않는 문은 별도의 줄에 두는 것이 좋습니다.



[[attribute-assignment-precedence]]
== Document Attributes - Attribute Assignment Precedence
=== 기본 속성 값 우선 순위
속성 할당 우선 순위는 높은 순서에서 낮은 순서로 나열하면 다음과 같습니다:

API 또는 CLI를 사용하여 정의된 속성
문서에 정의된 속성
해당되는 경우 속성의 기본값

imagesdir 속성을 사용하여 우선 순위가 어떻게 작동하는지 살펴보겠습니다.
imagesdir 속성의 기본값은 빈 문자열입니다. 따라서 imagesdir 속성에 값이 할당되지 않으면(문서, API 또는 CLI에서) 프로세서가 빈 문자열의 기본값을 할당합니다. 문서에서 imagesdir 속성이 설정되면(즉, images와 같은 새 값이 할당되면) 해당 값이 기본값을 재정의합니다. 마지막으로, API 또는 CLI를 통해 imagesdir 속성에 값이 할당되면 해당 값이 기본값과 문서에 할당된 값을 모두 재정의합니다.
다음 섹션에서 다룰 수정자를 사용하여 이 우선 순위 순서를 변경할 수 있습니다.
=== 할당 우선 순위 변경
속성 값의 끝 또는 속성 이름의 끝에 @ 우선 순위 수정자를 추가하여 API 또는 CLI를 통해 정의된 속성을 문서에서 재할당할 수 있습니다. 이 수정자를 추가하면 우선 순위가 낮아져 문서의 할당이 여전히 우선합니다. 이를 때때로 속성을 "소프트 설정"한다고 합니다. 이 기능은 속성에 대한 기본값을 할당하면서도 문서가 자신의 운명을 제어할 수 있도록 하는 데 유용할 수 있습니다.
@ 수정자는 할당이 이루어지기 전에 제거됩니다.
다음은 CLI에서 imagesdir을 낮은 우선 순위로 설정하는 방법을 보여주는 예입니다:
$ asciidoctor -a imagesdir=images@ doc.adoc
또는 속성 이름의 끝에 수정자를 배치할 수 있습니다:
$ asciidoctor -a imagesdir@=images doc.adoc
이제 문서 내에서 imagesdir 속성의 값을 재정의할 수 있습니다:
= Document Title
:imagesdir: new/path/to/images
CLI 또는 API에서 속성을 소프트 해제하려면 다음 구문을 사용할 수 있습니다:
!name=@
선행 !는 속성을 해제하고 @는 할당의 우선 순위를 낮춥니다. 이 할당은 거의 항상 기본값을 해제하면서도 문서가 새 값을 할당할 수 있도록 하는 데 사용됩니다. 그 중 하나의 예는 기본적으로 활성화되는 sectids입니다. !sectids=@는 설정을 끕니다.
이 추가 규칙을 반영하기 위해 앞에서 정의한 속성 할당 우선 순위 목록을 업데이트해 보겠습니다:

값이 @로 끝나지 않는 API 또는 CLI에 전달된 속성
문서에 정의된 속성
값 또는 이름이 @로 끝나는 API 또는 CLI에 전달된 속성
해당되는 경우 속성의 기본값

우선 순위 수정자가 적용되었는지 여부에 관계없이 속성 할당은 항상 기본값을 재정의합니다.



[[counters]]
== Document Attributes - Counters
카운터는 숫자 또는 라틴 문자의 임시 시퀀스를 저장하고 표시하는 데 사용됩니다.
카운터는 AsciiDoc에서 명확하게 정의되지 않은 기능이며 가능하면 사용을 피해야 합니다. 카운터를 사용하는 경우 목록, 테이블 열 또는 산문에서 시퀀스를 만드는 것과 같은 가장 기본적인 사용 사례에만 사용해야 합니다. ID(즉, 참조) 또는 참조 텍스트를 작성하는 데 카운터를 사용해서는 안 됩니다. 참조의 경계를 넘어 카운터를 사용하면 예기치 않은 동작이 발생할 가능성이 매우 높습니다.
카운터는 특수한 문서 속성으로 구현됩니다. 속성 이름 앞에 counter:가 붙은 속성 참조를 사용하여 카운터를 선언하고 표시합니다(예: {counter:name}). 카운터는 속성이므로 카운터 이름은 속성 이름과 동일한 규칙을 따릅니다. 가장 중요한 규칙은 카운터 이름의 문자는 소문자여야 한다는 것입니다.
counter: 속성 참조가 해결될 때마다 카운터 값이 증가하고 표시됩니다. 증가라는 용어는 속성 값을 시퀀스의 다음 값으로 전진시키는 것을 의미합니다. 카운터 값이 정수이면 1을 더합니다. 카운터 값이 문자이면 라틴 알파벳의 다음 문자로 이동합니다(예: a → b). 카운터의 기본 시작 값은 1입니다.
1부터 시작하는 시퀀스를 만들려면 여기에 표시된 대로 간단한 형식 {counter:name}을 사용합니다:
The salad calls for {counter:seq1}) apples, {counter:seq1}) oranges and {counter:seq1}) pears.
결과 출력은 다음과 같습니다:
The salad calls for 1) apples, 2) oranges and 3) pears.
섹션 제목에 카운터 값을 사용하려면 먼저 속성 참조를 사용하여 정의해야 합니다.
:seq1: {counter:seq1}
== Section {seq1}
The sequence in this section is {seq1}.
:seq1: {counter:seq1}
== Section {seq1}
The sequence in this section is {seq1}.
결과 출력은 다음과 같습니다:
Section 1
The sequence in this section is 1.
Section 2
The sequence in this section is 2.
표시하지 않고 카운터를 증가시키려면(즉, 시퀀스에서 항목을 건너뛰려면) 대신 counter2 접두사를 사용합니다:
{counter2:seq1}
counter2 속성 참조가 그 자체로 한 줄에 있으면 빈 단락이 생성됩니다. 이 부작용을 피하려면 가장 가까운 내용에 첨부해야 합니다.
증가시키지 않고 카운터의 현재 값을 표시하려면 다른 속성과 마찬가지로 카운터 이름을 참조합니다:
{counter2:pnum}This is paragraph {pnum}.
문자 시퀀스를 만들거나 1 이외의 값으로 숫자 시퀀스를 시작하려면 카운터를 처음 사용할 때 시작 값을 추가하여 지정합니다:
Dessert calls for {counter:seq1:A}) mangoes, {counter:seq1}) grapes and {counter:seq1}) cherries.
문자 시퀀스는 시작 값에 따라 a,b,c,…x,y,z,{,|…​ 또는 A,B,C,…​,X,Y,Z,[,…​ 중 하나로 실행됩니다. 따라서 26개 이상의 항목에는 실제로 유용하지 않습니다.
카운터의 시작 값은 문서의 해당 지점에서 카운터가 설정되지 않은 경우에만 인식됩니다. 그렇지 않으면 시작 값은 무시됩니다.
카운터 속성을 재설정하려면 속성 항목을 사용하여 해당 속성을 해제합니다. 속성 항목은 블록에 인접해야 합니다. 그렇지 않으면 무시됩니다.
The salad calls for {counter:seq1:1}) apples, {counter:seq1}) oranges and {counter:seq1}) pears.
:!seq1:
Dessert calls for {counter:seq1:A}) mangoes, {counter:seq1}) grapes and {counter:seq1}) cherries.
결과는 다음과 같습니다:
The salad calls for 1) apples, 2) oranges and 3) pears.
Dessert calls for A) mangoes, B) grapes and C) cherries.
다음은 테이블에서 부품 번호에 카운터를 사용하는 방법을 보여주는 전체 예입니다.
.Parts{counter2:index:0}
|===
|Part Id |Description
|PX-{counter:index}
|Description of PX-{index}
|PX-{counter:index}
|Description of PX-{index}
|===
해당 테이블의 출력은 다음과 같습니다:
[cols="1,1"]
|===
|Part Id |Description
|PX-1
|Description of PX-1
|PX-2
|Description of PX-2
|===



[[element-attributes]]
== Element Attributes
요소 속성은 AsciiDoc 구문에서 개별 블록 및 인라인 요소의 내장 설정을 제어하는 강력한 수단입니다. 또한 특정 요소에 인용 메타데이터 및 폴백 콘텐츠와 같은 추가 정보를 추가하는 데 사용할 수도 있습니다.
=== 요소 속성이란?
요소 속성은 문서의 개별 블록 요소 또는 인라인 요소(매크로 포함)에 적용할 수 있는 내장 및 사용자 정의 설정과 메타데이터를 정의합니다. include 지시문은 기술적으로 요소가 아니지만 include 지시문에도 요소 속성을 정의할 수 있습니다.
요소 속성은 위치 기반(값만) 또는 이름 기반(키/값 쌍)일 수 있습니다. 일부 내장 및 확장 요소는 위치 기반 속성을 이름 기반 속성에 매핑합니다. 각 요소는 미리 정의된 위치 기반 및/또는 이름 기반 요소 속성 집합을 인식합니다. 작성자는 확장 또는 문서 분석기에 정보를 전달하기 위해 원하는 수의 사용자 정의 요소 속성을 정의할 수 있습니다.
문서 속성과 마찬가지로 요소 속성에 대한 엄격한 스키마나 options 요소 속성의 값에 대한 엄격한 스키마는 없습니다. id, role, opts 및 title을 포함하여 모든 블록 요소와 대부분의 인라인 요소에서 공유하는 예약된 핵심 속성 집합이 있습니다. 특정 요소는 추가 속성과 옵션 값을 예약할 수 있습니다. 예를 들어, source 블록은 소스 언어를 설정하기 위해 lang 속성을 예약하고 행 번호를 활성화하기 위해 linenums 옵션을 예약합니다. 링크 매크로는 링크의 대상 창을 변경하기 위해 window 속성을 예약하고 크롤러가 링크를 따르지 않도록 하기 위해 nofollow 옵션을 예약합니다. 그렇지 않으면 요소 속성에 대한 스키마는 개방형이므로 확장에서 자체 목적으로 사용할 수 있습니다.
요소 속성은 일반적으로 다음 목적으로 사용됩니다:

요소의 ID 선언
개별 요소의 내장 기능 켜기 또는 끄기
개별 요소의 내장 기능 구성
인용 메타데이터, 폴백 텍스트, 링크 텍스트 및 대상 콘텐츠와 같은 사용자 정의 정보를 개별 요소에 적용
사용자 정의 역할과 동작을 개별 요소에 적용

문서 속성과 달리 요소 속성은 속성 목록을 사용하여 적용되는 요소에 직접 정의됩니다.
=== 속성 목록
속성 목록(종종 attrlist로 축약됨)을 사용하여 블록 및 인라인 요소에 속성을 할당할 수 있습니다.
예제 1. 속성 목록의 해부학
first-positional,second-positional,named="value of named"
속성 목록의 항목은 따옴표 안의 쉼표를 제외하고 쉼표로 구분됩니다. 속성 목록 항목에 사용되는 구문은 위치 기반 또는 이름 기반 속성인지 여부를 결정합니다. 항목을 구분하는 쉼표 뒤의 공백은 선택 사항입니다. 속성 목록이 구문 분석되는 방법에 대한 자세한 내용은 위치 기반 및 이름 기반 속성을 참조하세요.
블록 요소의 경우 속성 목록은 하나 이상의 블록 속성 라인 내에 배치됩니다. 블록 속성 라인은 블록의 시작(예: 여는 구분 기호 또는 단순 내용) 위에 있는 [로 시작하고 ]로 끝나는 텍스트 라인입니다. 이 라인은 블록 제목과 같은 다른 블록 메타데이터 라인과 교차될 수 있습니다. [ 및 ] 경계 안에 묶인 텍스트는 유효한 속성 목록으로 간주되며 해당 라인은 자동으로 소비됩니다. 텍스트를 구문 분석할 수 없는 경우 오류 메시지가 로그에 기록됩니다.
예제 2. 블록 속성 라인
[style,second-positional,named="value of named"]
단락의 시작 줄이 블록 속성 라인의 구문과 우연히 일치할 수 있습니다. 이 경우 {empty}를 라인 끝에 추가하여 구문 일치를 방해하세요.
블록 및 인라인 매크로의 경우 속성 목록은 매크로의 대괄호 사이에 배치됩니다. 블록 매크로의 속성 목록에 있는 텍스트는 이스케이프할 필요가 없습니다. 인라인 매크로의 경우 매크로를 일찍 끝내거나 원치 않는 대체를 방지하기 위해 속성 목록의 텍스트를 이스케이프해야 할 수 있습니다.
예제 3. 속성 목록이 있는 블록 매크로
name::target[first-positional,second-positional,named="value of named"]
서식 있는 텍스트의 경우 속성 목록은 텍스트 묶음 앞의 대괄호 안에 배치됩니다. 그러나 서식 있는 텍스트는 속성 목록의 제한된 형식만 지원합니다. 특히 이름 기반 속성이 아닌 속성 단축 구문만 지원합니다.
예제 4. 속성 목록이 있는 서식 있는 텍스트
[#idname.rolename]id와 role이 있는 텍스트
속성 목록은:

블록, 매크로 및 인라인 요소에 적용되며,
위치 기반 및 이름 기반 속성을 포함할 수 있으며,
요소가 재정의를 지원하는 경우 문서 속성보다 우선합니다.

이전 섹션에서 언급했듯이 요소 속성에 대한 스키마는 개방형입니다. 인식되지 않는 위치 기반 또는 이름 기반 속성은 요소에 저장되지만 동작이나 출력에 영향을 미치지 않습니다. 확장은 이 보조 정보를 사용하여 동작에 영향을 미치거나 출력을 사용자 정의할 수 있습니다.



[[positional-and-named-attributes]]
=== Element Attributes - Positional and Named Attributes

이 페이지에서는 요소의 위치 기반 속성과 이름 기반 속성의 차이점과 속성 목록을 구문 분석하는 규칙에 대해 설명합니다.
=== 위치 기반 속성
값으로만 구성된 속성 목록의 항목을 위치 기반 속성이라고 합니다. 위치는 모든 이름 기반 속성이 제거된 후 항목의 1부터 시작하는 인덱스입니다(따라서 서로 섞여 있을 수 있음).
블록 또는 매크로가 위치 기반 속성에 대한 매핑을 정의하면 위치 기반 속성이 암시적 속성 이름에 이중으로 할당될 수 있습니다. 다음은 이러한 매핑의 몇 가지 예입니다:

icon: 1 ⇒ size
image: 및 image:: 1 ⇒ alt (text), 2 ⇒ width, 3 ⇒ height
구분된 블록: 1 ⇒ 블록 스타일 및 속성 단축 구문
기타 인라인 인용된 텍스트: 1 ⇒ 속성 단축 구문
link: 및 xref: 1 ⇒ text
사용자 정의 블록 및 매크로도 위치 기반 속성을 지정할 수 있습니다.

예를 들어, 다음 두 개의 이미지 매크로는 동일합니다.
image::sunset.jpg[Sunset,300,400]
image::sunset.jpg[alt=Sunset,width=300,height=400]
두 번째 매크로는 첫 번째 매크로와 동일하지만 긴 형식으로 작성되었습니다.
==== 블록 스타일 및 속성 단축 구문
모든 블록(섹션 포함)의 첫 번째 위치 기반 속성은 특별합니다. 블록 스타일을 정의하는 데 사용됩니다. 또한 ID, 역할 및 옵션 속성을 정의하기 위한 단축 구문을 지원합니다. 이 단축 구문은 서식 있는 텍스트에도 사용할 수 있지만, 서식 있는 텍스트는 기술적으로 속성을 지원하지 않습니다.
속성 단축 구문은 HAML 및 Slim 템플릿 언어에서 영감을 받아 작성자가 일부 입력을 저장할 수 있는 방법으로 고안되었습니다. 이름 속성의 긴 형식을 사용하는 대신 특수 마커가 접두사로 붙은 값으로 할당을 압축할 수 있습니다. 마커는 다음과 같이 매핑됩니다:

`# - ID`
. - 역할
% - 옵션

각 단축 항목은 이전 항목에 직접 인접하여 배치되며, 선택적 블록 스타일 바로 뒤에서 시작됩니다. 스타일을 제외하고는 항목의 순서는 중요하지 않습니다. 스타일은 첫 번째로 와야 합니다.
다음은 이 단축 구문을 사용하여 섹션에 ID를 설정하는 방법을 보여주는 예입니다:
[#custom-id]
== Section with Custom ID
단축 항목은 블록 스타일 뒤에 와야 합니다(있는 경우). 다음은 이 단축 구문을 사용하여 부록 섹션에 ID를 설정하는 방법을 보여주는 예입니다:
[appendix#custom-id]
== Appendix with Custom ID
다음은 단축 구문을 사용하여 목록의 ID, 역할 및 옵션을 설정하는 블록의 예입니다. 구체적으로 이 구문은 ID를 rules로 설정하고, prominent 역할을 추가하고, incremental 옵션을 설정합니다.
[#rules.prominent%incremental]

Work hard
Play hard
Be happy

블록에는 여러 역할과 옵션이 있을 수 있으므로 이러한 단축 항목이 반복될 수 있습니다. 다음은 테이블에 여러 옵션을 설정하는 방법을 보여주는 예입니다. 구체적으로 이 구문은 header, footer 및 autowidth 옵션을 설정합니다.
[%header%footer%autowidth]
|===
|Header A |Header B
|Footer A |Footer B
|===
이 단축 구문은 서식 있는 텍스트에도 나타납니다. 다음은 ID를 설정하고 강조 구문에 역할을 추가하는 방법을 보여주는 예입니다. 구체적으로 이 구문은 ID를 free-world로 설정하고 goals 역할을 추가합니다.
[#free-world.goals]free the world
서식 있는 텍스트는 스타일을 지원하지 않으므로 첫 번째이자 유일한 위치 기반 속성은 항상 단축 구문입니다.
=== 이름 기반 속성
이름 기반 속성은 = 문자로 구분된 이름과 값으로 구성됩니다(예: name=value).
값에 공백, 쉼표 또는 따옴표 문자가 포함된 경우 값을 큰따옴표나 작은따옴표로 묶어야 합니다(예: name="value with space"). 다른 모든 경우에는 주변 따옴표가 선택 사항입니다.
값에 값을 묶는 데 사용된 것과 동일한 따옴표 문자가 포함된 경우 값의 따옴표 문자 앞에 백슬래시를 붙여 이스케이프해야 합니다(예: `value="the song "Dark Horse""").
묶는 따옴표를 사용하면 구문 분석된 값에서 삭제되고 이스케이프된 따옴표에서 앞의 백슬래시가 삭제됩니다.
==== 이름 기반 속성 해제
이름 기반 속성을 정의하지 않으려면 값을 None으로 설정합니다(대소문자 구분).
=== 속성 목록 구문 분석
요소의 속성을 정의하는 데 사용되는 소스 텍스트를 attrlist라고 합니다. attrlist는 항상 한 쌍의 대괄호로 묶입니다. 이는 블록 속성과 블록 또는 인라인 매크로의 속성에 모두 적용됩니다. 프로세서는 attrlist를 개별 속성 항목으로 분할하고, 각 항목이 위치 기반 속성인지 이름 기반 속성인지 확인하고, 그에 따라 항목을 구문 분석하고, 결과를 노드의 속성으로 할당합니다.
개별 속성의 경계를 정의하는 규칙과 속성이 위치 기반인지 이름 기반인지는 아래에 정의되어 있습니다. 이 규칙에서 name은 단어 문자(문자 또는 숫자) 뒤에 임의 개수의 단어 또는 - 문자로 구성됩니다(예: see-also).
attrlist가 구문 분석되기 전에 속성 참조가 확장됩니다(즉, 속성 대체가 적용됨).
속성 구문 분석은 속성 목록 문자열의 시작 부분 또는 이전에 식별된 구분 기호(,) 뒤에서 진행됩니다.
속성 목록의 첫 번째 문자는 탭이나 공백일 수 없습니다. 후속 속성의 경우 선행 공백 또는 탭 문자는 건너뜁니다.
유효한 속성 이름이 발견되고 그 뒤에 등호(=)가 오는 경우 파서는 이를 이름 기반 속성으로 인식합니다. 등호(=) 다음의 텍스트와 다음 쉼표 또는 목록의 끝까지가 속성 값으로 간주됩니다. 등호(=) 주위와 값 끝의 공백 및 탭 문자는 무시됩니다.
그렇지 않으면 다음 구분 기호 또는 목록의 끝에서 끝나는 값을 가진 위치 기반 속성입니다. 값의 경계에 있는 공백 또는 탭 문자는 무시됩니다.
속성 값을 구문 분석하려면:

첫 번째 문자가 따옴표가 아닌 경우 다음 구분 기호 또는 문자열의 끝까지 문자열을 읽습니다.
첫 번째 문자가 큰따옴표(즉, ")인 경우 다음 이스케이프되지 않은 큰따옴표까지 또는 닫는 큰따옴표가 없는 경우 다음 구분 기호까지 문자열을 읽습니다. 닫는 큰따옴표가 있으면 묶는 큰따옴표 문자가 제거되고 이스케이프된 큰따옴표 문자는 이스케이프되지 않습니다. 그렇지 않으면 초기 큰따옴표가 유지됩니다.
다음 문자가 작은따옴표(즉, ')인 경우 다음 이스케이프되지 않은 작은따옴표까지 또는 닫는 작은따옴표가 없는 경우 다음 구분 기호까지 문자열을 읽습니다. 닫는 작은따옴표가 있으면 묶는 작은따옴표 문자가 제거되고 이스케이프된 작은따옴표 문자는 이스케이프되지 않습니다. 그렇지 않으면 초기 작은따옴표가 유지됩니다. 닫는 작은따옴표가 있고 첫 번째 문자가 이스케이프된 작은따옴표가 아닌 경우 대체에 설명된 대로 값에 대체가 수행됩니다.

=== 닫는 대괄호를 이스케이프해야 하는 경우
attrlist의 끝 기호가 닫는 대괄호이므로 속성의 값에 닫는 대괄호가 나타나면 때로는 이스케이프해야 합니다.
블록 속성 목록, 블록 매크로 및 include 지시문과 같은 줄 지향 구문에서는 attrlist 자체에 나타나는 닫는 대괄호를 이스케이프할 필요가 없습니다. 파서는 이미 줄 끝에서 닫는 대괄호를 찾아야 한다는 것을 알고 있기 때문입니다.
인라인 매크로와 같은 인라인 요소의 attrlist에 닫는 대괄호가 나타나면 백슬래시를 사용하거나 문자 참조 &#93;을 사용하여 이스케이프해야 합니다. 각주의 링크 매크로와 같이 대체 순서에 영향을 받는 몇 가지 예외가 있습니다.
=== 대체
속성 참조는 attrlist가 구문 분석되기 전에 확장된다는 점을 기억하세요. 따라서 속성 대체만 적용하는 데 관심이 있는 경우 값에 대체를 강제로 적용할 필요가 없습니다. 속성 대체는 이 시점에서 이미 적용되었습니다.
속성 이름(위치 기반 속성의 경우) 또는 값(이름 기반 속성의 경우)이 작은따옴표로 묶여 있고(예: citetitle='Processed by https://asciidoctor.org'), 속성이 블록의 attrlist에 정의되어 있는 경우 할당 시 정상적인 대체 그룹이 값에 적용됩니다. 값이 따옴표로 묶여 있지 않거나 큰따옴표로 묶여 있는 경우 속성 참조 확장을 제외하고는 특별한 처리가 수행되지 않습니다.
값에 값을 묶는 데 사용된 것과 동일한 따옴표 문자가 포함된 경우 값의 따옴표 문자 앞에 백슬래시를 붙여 이스케이프합니다(예: `citetitle='A 'use case' diagram, generated by https://plantuml.com'`).


[[id-attribute]]
=== Element Attributes - ID Attribute
[[role-attribute]]
=== Element Attributes - Role Attribute
[[options-attribute]]
=== Element Attributes - Options Attribute

---

[[document-header]]
== Document Header
[[document-title]]
== Document Header - Document Title
[[subtitle]]
== Document Header - Document Title - Subtitle
[[author-information]]
== Document Header - Author Information
[[using-the-author-line]]
== Document Header - Author Information - Using the Author Line
[[add-multiple-authors-to-a-document]]
== Document Header - Author Information - Add Multiple Authors to a Document
[[assign-author-and-email-with-attribute-entries]]
== Document Header - Author Information - Assign Author and Email with Attribute Entries
[[reference-the-author-information]]
== Document Header - Author Information - Reference the Author Information
[[compound-author-names]]
== Document Header - Author Information - Compound Author Names
[[revision-information]]
== Document Header - Revision Information
[[using-the-revision-line]]
== Document Header - Revision Information - Using the Revision Line
[[assign-revision-attributes-with-attribute-entries]]
== Document Header - Revision Information - Assign Revision Attributes with Attribute Entries
[[version-label-attribute]]
== Document Header - Revision Information - Version Label Attribute
[[reference-the-revision-attributes]]
== Document Header - Revision Information - Reference the Revision Attributes
[[document-metadata]]
== Document Header - Document Metadata
[[document-header-reference]]
== Document Header - Document Header Reference

---



[[document-type]]
== Document Type

문서 유형(doctype이라고도 함)은 AsciiDoc 문서의 예상 구조를 선언합니다. AsciiDoc은 고정된 문서 유형 집합을 정의합니다. 각 문서 유형은 서로 다른 사용 사례에 맞게 AsciiDoc 문서의 허용된 구조에 약간의 변형을 제공합니다.

기본 doctype은 article이며, 다른 doctype이 구축되는 기본 구조를 제공합니다. book doctype은 부분 섹션 역할을 하는 여러 레벨-0 섹션을 허용합니다. manpage doctype은 볼륨 번호, 매뉴얼, 용도와 같은 manpage의 표준 메타데이터를 정의하기 위한 확장된 헤더를 제공합니다. inline doctype은 임베디드 시나리오를 위한 것입니다.

=== 문서 유형

*Article (article)* 
....
기본 doctype입니다. DocBook에서 이는 부록, 초록, 참고 문헌, 용어집 및 색인 섹션을 포함합니다. 책이나 매뉴얼 페이지를 만들지 않는 한 doctype에 대해 걱정할 필요가 없습니다. 기본값으로 충분합니다.
....

*Book (book)*
....
최상위 제목을 부제로 사용하는 추가 기능과 함께 article doctype을 기반으로 하며, 부록, 헌사, 서문, 참고 문헌, 용어집, 색인 및 colophon을 포함합니다. 또한 여러 부분으로 구성된 책의 개념이 있지만, 일반 책과의 구별은 내용에 의해 결정됩니다. 책에는 장과 특수 섹션만 있는 반면, 여러 부분으로 구성된 책은 각각 하나 이상의 장 또는 특수 섹션을 포함하는 부분으로 나뉩니다.
....

*Man page*
....
(manpage) Unix 및 Unix 계열 운영 체제용 roff 또는 HTML 형식의 매뉴얼 페이지(man page)를 생성하는 데 사용됩니다. 이 doctype은 파서에게 AsciiDoc 내용을 man page로 구성하기 위한 특수 문서 헤더와 섹션 이름 지정 규칙을 인식하도록 지시합니다. AsciiDoc을 사용하여 man page를 구조화하고 Asciidoctor를 사용하여 생성하는 방법에 대한 자세한 내용은 AsciiDoc에서 매뉴얼 페이지 생성을 참조하세요.
....

*Inline (inline)*
....
입력 텍스트에 인라인 AsciiDoc 서식을 적용하되 블록 요소로 감싸지 않으려는 경우가 있을 수 있습니다. 예를 들어 Asciidoclet 프로젝트(Javadoc의 AsciiDoc)에서는 Javadoc 태그의 텍스트에 대해 인라인 서식만 필요합니다.
....

=== 인라인 doctype 규칙

인라인 doctype에 대한 규칙은 다음과 같습니다:

- AsciiDoc 소스에서 단일 단락만 읽습니다.
- 인라인 서식이 적용됩니다.
- 출력이 일반 단락 태그로 감싸지지 않습니다.

다음과 같은 입력이 주어졌을 때:
[source,asciidoc]
----
https://asciidoctor.org[AsciiDoc] is a lightweight markup language...
----
doctype=inline과 backend=html5 옵션으로 처리하면 다음과 같이 생성됩니다:

[source,html]
----
<a href="https://asciidoctor.org">AsciiDoc</a> is a <em>lightweight</em> markup language…
----
인라인 doctype을 사용하면 AsciiDoc 프로세서가 비구조화된(인라인) 텍스트부터 완전한 독립 문서까지 전체 범위의 애플리케이션을 다룰 수 있습니다!


[[sections]]
== Sections

[[section-titles-and-levels]]
=== Section Titles and Levels
[[activate-section-title-links]]
==== Activate Section Title Links
[[autogenerate-section-ids]]
=== Autogenerate Section IDs
[[change-id-prefix-separator]]
==== Change the ID Prefix and Separator
[[assign-custom-ids-reference-text]]
=== Assign Custom IDs and Reference Text
[[section-numbers]]
=== Section Numbers
[[section-styles-articles-books]]
=== Section Styles for Articles and Books
[[hide-special-section-titles]]
==== Hide Special Section Titles
[[number-special-sections]]
==== Number Special Sections
[[colophon]]
==== Colophon
[[dedication]]
==== Dedication
[[abstract-section]]
==== Abstract (Section)
[[abstract-block]]
==== Abstract (Block)
[[preface]]
==== Preface
[[book-parts]]
==== Book Parts
[[part-numbers-signifier]]
===== Part Numbers and Signifier
[[chapters]]
==== Chapters
[[appendix]]
==== Appendix
[[glossary]]
==== Glossary
[[bibliography]]
==== Bibliography
[[index]]
==== Index
[[section-attributes-styles-reference]]
=== Section Attributes and Styles Reference

[[paragraphs]]
== Paragraphs
[[hard-line-breaks]]
=== Hard Line Breaks
[[preamble-lead-style]]
=== Preamble and Lead Style
[[paragraph-alignment]]
=== Paragraph Alignment

[[discrete-headings]]
== Discrete Headings

[[breaks]]
== Breaks

[[text-formatting-punctuation]]
== Text Formatting and Punctuation
[[bold]]
=== Bold
[[italic]]
=== Italic
[[monospace]]
=== Monospace
[[literal-monospace]]
=== Literal Monospace
[[text-span-built-in-roles]]
=== Text Span and Built-in Roles
[[highlight]]
=== Highlight
[[quotation-marks-apostrophes]]
=== Quotation Marks and Apostrophes
[[subscript-superscript]]
=== Subscript and Superscript
[[using-custom-inline-styles]]
=== Using Custom Inline Styles
[[troubleshoot-unconstrained-formatting-pairs]]
=== Troubleshoot Unconstrained Formatting Pairs

---
== Lists



[[unordered-lists]]
== Lists - Unordered Lists

AsciiDoc에서는 지정된 마커로 시작하는 행을 사용하여 정렬되지 않은 목록을 만들 수 있습니다. 정렬되지 않은 목록은 디스크(별칭 글머리 기호)와 같은 기호가 접두사로 붙은 항목 목록입니다.

AsciiDoc은 별표 또는 하이픈을 사용하여 목록 항목을 식별하는 잘 정립된 규칙을 기반으로 합니다. 인접한 목록 항목은 단일 목록으로 결합됩니다. 정렬되지 않은 목록은 마커 문자 또는 길이(별표만 해당)를 변경하여 중첩될 수 있습니다. 목록 항목에는 첨부된 블록이 포함될 수 있습니다. 또한 다른 유형의 목록과 교차될 수도 있습니다.

=== 기본 정렬되지 않은 목록

아래 예제에서 각 목록 항목은 정렬되지 않은 목록 항목을 지정하는 AsciiDoc 구문인 별표(*)를 사용하여 표시됩니다.

[source,ASCIIDOC]
----
* Edgar Allan Poe
* Sheri S. Tepper
* Bill Bryson
----

목록 항목의 첫 번째 텍스트 행은 마커(*)에서 최소한 하나의 공백으로 오프셋되어야 합니다. 목록 앞뒤에는 빈 줄이 필요합니다. 또한 목록 항목 사이에 빈 줄이 허용되지만 필수는 아닙니다.

.렌더링된 정렬되지 않은 목록
====
* Edgar Allan Poe
* Sheri S. Tepper
* Bill Bryson
====

마침표(.)를 제목 앞에 붙여 목록에 제목을 추가할 수 있습니다.

[source,ASCIIDOC]
----
.Kizmet's Favorite Authors
Edgar Allan Poe
Sheri S. Tepper
Bill Bryson
----

.렌더링된 제목이 있는 정렬되지 않은 목록
====
.Kizmet's Favorite Authors
* Edgar Allan Poe
* Sheri S. Tepper
* Bill Bryson
==== 

별표 대신 하이픈(-)을 사용하여 목록 항목을 표시하려는 것이 본능이었나요? 어떻게 될까요? 그것도 작동합니다!


[source,ASCIIDOC]
----
- Edgar Allan Poe
- Sheri S. Tepper
- Bill Bryson
----

하이픈 마커(-)는 중첩 목록에 사용할 수 없으므로 한 수준만 있는 목록에 하이픈을 사용해야 합니다. 이제 중첩 목록에 대해 언급했으니 다음 섹션으로 넘어가서 여러 수준의 목록을 만드는 방법을 배워보겠습니다.

====
[.text-center]
*목록 강제 분리*

인접한 목록이 있는 경우 서로 융합하려는 경향이 있습니다. 목록을 강제로 분리하려면 두 목록 사이에 빈 줄로 둘러싸인 행 주석(//)을 삽입하세요. 다음은 행 주석의 - 텍스트가 "목록 끝" 마커 역할을 하는 예입니다:

[source,ASCIIDOC]
----
Apples
Oranges

//-

Walnuts
Almonds
----

이 기법은 모든 목록 유형에 적용됩니다. 자세한 내용은 목록 분리를 참조하세요.

====

=== 중첩된 정렬되지 않은 목록

항목을 중첩하려면 마커에 별표(*)를 추가하기만 하면 됩니다. 각 후속 수준에 대해 이 작업을 계속 수행하세요.

[source,ASCIIDOC]
----
.Possible DefOps manual locations
* West wood maze
** Maze heart
*** Reflection pool
** Secret exit
* Untracked file in git repository
----

.렌더링된 중첩된 정렬되지 않은 목록
====
.Possible DefOps manual locations
* West wood maze
** Maze heart
*** Reflection pool
** Secret exit
* Untracked file in git repository
====

원하는 경우 마커를 왼쪽 여백에서 임의의 공백 수만큼 들여쓸 수 있습니다. 들여쓰기는 중요하지 않으며 중첩 수준을 시각화하는 데 도움이 될 수 있습니다.

정렬되지 않은 목록은 원하는 깊이까지 중첩할 수 있습니다. 그러나 일부 인터페이스는 특정 깊이 이후에 목록을 평평하게 만들기 시작한다는 점에 유의하세요. 예를 들어 GitHub은 중첩 수준이 10 이상이면 목록을 평평하게 만들기 시작합니다.

[source,ASCIIDOC]
----
* Level 1 list item
** Level 2 list item
*** Level 3 list item
**** Level 4 list item
***** Level 5 list item
****** etc.
* Level 1 list item
----


.정렬되지 않은 목록은 원하는 깊이까지 중첩될 수 있습니다
====
* Level 1 list item
** Level 2 list item
*** Level 3 list item
**** Level 4 list item
***** Level 5 list item
****** etc.
* Level 1 list item
====

==== 목록 깊이 결정

별표 수가 중첩 수준을 나타내는 것처럼 보일 수 있지만 깊이가 결정되는 방식은 아닙니다. 새 수준은 발견된 각 고유 마커에 대해 생성됩니다. 예를 들어 두 개의 별표 대신 하이픈 마커를 사용하여 두 번째 수준을 만들 수 있습니다.

.Example 1. 하이픈을 사용하여 두 번째 수준을 표시하는 것은 권장되지 않습니다.
[source,ASCIIDOC]
----
* Level 1 list item
- Level 2 list item
* Level 1 list item
----

그러나 마커 길이(즉, 별표 수)가 중첩 수준과 같다는 규칙을 따르는 것이 훨씬 더 직관적입니다. 하이픈은 첫 번째 수준의 마커로만 사용해야 합니다.

*마커 길이 = 중첩 수준*

결국 우리는 있는 그대로 읽을 수 있는 일반 텍스트 마크업을 목표로 하고 있습니다.

=== 마커

렌더링될 때 정렬되지 않은 목록 항목은 선행 마커(글머리 기호)로 지정됩니다(목록을 정의하는 데 사용되는 마커와 혼동하지 마세요). 이 마커는 목록 스타일을 사용하여 제어할 수 있습니다. 마커를 지정하지 않으면 렌더러에서 기본 마커를 선택합니다.

==== 기본 마커

기본적으로 AsciiDoc은 정렬되지 않은 목록의 첫 번째 세 수준이 렌더링될 때 디스크, 원, 사각형 마커를 사용하여 스타일이 지정된다고 가정합니다. 다음 목록을 고려해 보세요:

[source,ASCIIDOC]
----
* disc
** circle
*** square
----

.중첩된 목록에 대한 기본 교체 마커
====
* disc
** circle
*** square
====

첫 번째 수준의 마커는 디스크(채워진 원), 두 번째 수준은 원(윤곽선), 세 번째 수준은 사각형(채워짐)인 것을 확인하세요. AsciiDoc 프로세서는 모델이나 변환된 출력에서 이러한 마커를 명시적으로 지정하지 않습니다. 오히려 이러한 기본값은 HTML에서 확립된 규칙을 준수하는 렌더러(예: CSS)에 의해 추가됩니다.

세 번째 중첩 수준을 넘어서는 마커 선택은 지정되지 않습니다. 일반적으로 렌더러는 앞의 예제에 표시된 대로 사각형 마커를 계속 사용합니다.

==== 사용자 정의 마커

AsciiDoc은 목록에 대해 다양한 마커 스타일을 제공합니다. 목록 마커는 목록의 블록 스타일을 사용하여 지정할 수 있습니다.

정렬되지 않은 목록 마커는 다음 블록 스타일 중 하나를 사용하여 설정할 수 있습니다:

- square
- circle
- disc
- none 또는 no-bullet(들여쓰기되었지만 글머리 기호 없음)
- unstyled(들여쓰기나 글머리 기호 없음)(DocBook 출력에서는 지원되지 않음)

[NOTE]
====
이러한 스타일은 기본 Asciidoctor 스타일시트에서 지원됩니다.
====

스타일 이름이 있는 경우 다음과 같이 정렬되지 않은 목록 요소에 할당됩니다:

*HTML의 경우*
스타일 이름이 <ul> 요소의 class 속성에 할당됩니다.

*DocBook의 경우*
스타일 이름이 <itemizedlist> 요소의 mark 속성에 할당됩니다.

사각형 마커가 있는 정렬되지 않은 목록은 다음과 같습니다:
[source,ASCIIDOC]
----
[square]
* one
* two
* three
----

.사각형 마커가 있는 목록
====
[square]
* one
* two
* three
====

목록 스타일이 설정되면 다시 설정될 때까지 해당 스타일이 모든 중첩 목록에 사용됩니다. 교체를 더 이상 유추할 수 없으므로 중단된다고 가정합니다. 상속된 스타일은 모델에 지정되지 않지만 렌더러(예: CSS)에 의해 적용됩니다. 예를 들어 최상위 목록에서 목록 스타일을 circle로 설정하면 모든 수준에 사용됩니다.

[source,ASCIIDOC]
----
[circle]
* circles
** all
*** the
**** way
***** down
----

.일단 설정되면 목록 스타일이 상속됩니다
====
[circle]
* circles
** all
*** the
**** way
***** down
====

상속된 스타일은 모든 수준에서 설정하거나 재설정할 수 있습니다.
[source,ASCIIDOC]
----
[square]
* squares
** up top

[circle]
*** circles
**** down below
----

.목록 스타일을 재설정할 수 있습니다
====
[square]
* squares
** up top
[circle]
*** circles
**** down below
====



[[ordered-lists]]
== Lists - Ordered Lists

=== 기본 정렬된 목록

때로는 목록의 항목에 번호를 매겨야 합니다. 본능적으로 다음 목록과 같이 각 항목 앞에 숫자를 붙일 수 있습니다:

[source,ASCIIDOC]
----
1. Protons
2. Electrons
3. Neutrons
----

위의 방법도 작동하지만 번호 매기기가 명확하므로 AsciiDoc 프로세서는 번호를 생략하면 자동으로 삽입합니다:

[source,ASCIIDOC]
----
. Protons
. Electrons
. Neutrons
----

====
1. Protons
2. Electrons
3. Neutrons
====

정렬된 목록을 명시적으로 번호 매기면 목록 번호를 수동으로 순차적으로 유지해야 합니다. 그렇지 않으면 경고가 표시됩니다. 이는 다른 경량 마크업 언어와 다릅니다. 하지만 그렇게 하는 데는 이유가 있습니다.

명시적 번호 매기기는 목록의 번호 오프셋을 조정하는 한 가지 방법입니다. 예를 들어 다음과 같이 입력할 수 있습니다:


[source,ASCIIDOC]
----
Step four
Step five
Step six
----

그러나 수동 작업 없이 동일한 결과를 얻을 수 있는 더 간단한 방법이 있습니다. 목록의 start 속성을 사용하여 번호를 시작할 숫자를 정의할 수 있습니다.
[source,ASCIIDOC]
----
[start=4]
. Step four
. Step five
. Step six
----

start 값은 loweralpha와 같은 다른 번호 매기기 스타일을 사용할 때에도 항상 양의 정수 값입니다.

====
[.text-center]
*start 속성을 사용하지 말아야 할 때*

정렬된 목록 항목에 이미지, 소스 블록 또는 테이블과 같은 블록 내용이 포함된 경우 목록의 다음 항목 번호가 1로 재설정되는 것을 관찰할 수 있습니다. 실제로 목록 연속이 누락되어 번호가 재설정되는 새 목록이 시작되었습니다.

이러한 경우에는 start 속성을 사용하여 번호 매기기를 수정하려고 해서는 안 됩니다. 목록에 항목이 추가될 때 수동 조정이 필요할 뿐만 아니라 깨지는 원인이 되는 기본 의미론적 문제를 해결하지 못합니다. 대신 목록 항목에 첨부하려는 각 블록 요소 사이에 목록 연속을 사용하여 목록 항목이 연속되도록 하세요. 목록 연속은 주어진 항목 내의 블록을 함께 붙이고 동일한 수준의 들여쓰기를 유지합니다.

- 목록 연속을 사용하는 방법에 대한 자세한 내용은 복잡한 목록 항목 페이지를 참조하세요.
- 복잡한 정렬된 목록에서 사용되는 목록 연속의 예는 GitHub의 이 .adoc 파일에 있는 시작 단계를 참조하세요.
- 생성된 배포 가이드의 빠른 시작 시작 섹션에서 해당 시작 단계가 최종 출력에서 어떻게 보이는지 확인하세요. 목록 연속은 단계 2가 1로 재설정되는 것을 방지합니다. 또한 별도의 AsciiDoc 파일에서 가져온 단계 5가 1로 재설정되는 것을 방지합니다.
====

목록 항목을 역순으로 표시하려면 reversed 옵션을 추가하세요:
[source,asciidoc]
----
[%reversed]
.Parts of an atom
. Protons
. Electrons
. Neutrons
----

====
[%reversed]
.Parts of an atom
. Protons
. Electrons
. Neutrons
====

점 바로 뒤에 텍스트를 붙여 행 앞에 점을 붙여 목록에 제목을 지정할 수 있습니다(점 뒤에 공백을 두지 않음).

다음은 제목이 있는 목록의 예입니다:

[source,asciidoc]
----
.Parts of an atom
. Protons
. Electrons
. Neutrons
----

====
.Parts of an atom
. Protons
. Electrons
. Neutrons
====

=== 중첩된 정렬된 목록

각 항목 앞에 하나 이상의 점을 사용하여 중첩된 항목을 만듭니다.

[source,asciidoc]
----
. Step 1
. Step 2
.. Step 2a
.. Step 2b
. Step 3
----

AsciiDoc은 중첩 수준마다 다른 번호 체계를 선택합니다. 이전 목록이 렌더링되는 방식은 다음과 같습니다:

.중첩된 정렬된 목록
====
. Step 1
. Step 2
.. Step 2a
.. Step 2b
. Step 3
====

[TIP]
====
정렬되지 않은 목록의 별표와 마찬가지로 정렬된 목록의 점 수는 중첩 수준을 나타내지 않습니다. 그러나 점 수가 중첩 수준과 같다는 규칙을 따르는 것이 훨씬 더 직관적입니다.

*점 수 = 중첩 수준*

다시 말하지만, 우리는 있는 그대로 읽을 수 있는 일반 텍스트 마크업을 목표로 합니다.

====

정렬된 목록, 정렬되지 않은 목록, 설명 목록의 세 가지 목록 유형을 단일 하이브리드 목록 내에서 혼합하고 일치시킬 수 있습니다. AsciiDoc 구문은 우리 인간에게 가장 직관적인 항목 간의 관계를 유추하기 위해 노력합니다.

다음은 정렬된 목록 내부에 정렬되지 않은 목록을 중첩하는 예입니다:

[source,asciidoc]
----
. Linux
* Fedora
* Ubuntu
* Slackware
. BSD
* FreeBSD
* NetBSD
----

====
. Linux
* Fedora
* Ubuntu
* Slackware
. BSD
* FreeBSD
* NetBSD
====

항목을 펼치고 중첩된 목록을 들여쓰면 더 읽기 쉽습니다:

[source,asciidoc]
----
. Linux

  * Fedora
  * Ubuntu
  * Slackware

. BSD

  * FreeBSD
  * NetBSD
----

설명 목록 페이지에서는 세 가지 목록 유형을 모두 결합하는 방법을 보여줍니다.

=== 번호 스타일

정렬된 목록의 경우 AsciiDoc은 lowergreek 및 decimal-leading-zero와 같은 번호 매기기 스타일을 지원합니다. 정렬된 목록에 적용할 수 있는 번호 매기기 스타일의 전체 목록은 다음과 같습니다:

[cols="1,2"]
|===
|*스타일* |*설명*
|arabic |decimal
|decimal^[1]^ |decimal-leading-zero
|loweralpha |lower-alpha
|upperalpha |upper-alpha
|lowerroman |lower-roman
|upperroman |upper-roman
|lowergreek^[1]^ |lower-greek
|===

^[1]^이 스타일은 HTML 변환기에서만 지원되는 스타일입니다.


다음은 헤더 행에 표시된 블록 스타일에 의해 정의된 다양한 번호 매기기 스타일을 보여주는 몇 가지 예입니다:

[cols="1,1,1,1",options="header"]
|===
| *[arabic]*^[2]^ | *[decimal]* | *[loweralpha]* | *[lowergreek]*

| 1. one | 01. one | a. one | α. one
| 2. two | 02. two | b. two | β. two
| 3. three | 03. three | c. three | γ. three
|===
^[2]^ 블록 스타일이 지정되지 않은 경우 기본 번호 매기기

[TIP]
====
사용자 정의 번호 매기기 스타일은 사용자 정의 역할을 사용하여 구현할 수 있습니다. 스타일시트에서 list-style-type 속성을 원하는 값으로 설정하는 새 클래스 선택기(예: .custom)를 정의하세요. 그런 다음 해당 번호 매기기를 적용하려는 모든 목록에 해당 클래스의 이름을 역할로 할당하세요.
====

역할 단축키(.custom)가 정렬된 목록에 사용되면 번호 매기기 스타일이 더 이상 생략되지 않습니다.

스타일을 설정하여 모든 수준의 번호 체계를 재정의할 수 있습니다(블록 속성 목록의 첫 번째 위치 항목). start 속성을 사용하여 시작 번호를 설정할 수도 있습니다:

[source,asciidoc]
----
[lowerroman,start=5]
. Five
. Six
[loweralpha]
.. a
.. b
.. c
. Seven
----

====
[lowerroman,start=5]
. Five
. Six
[loweralpha]
.. a
.. b
.. c
. Seven
====

[IMPORTANT]
====
start 속성은 다른 번호 매기기 스타일을 사용할 때에도 숫자여야 합니다. 예를 들어 알파벳 목록을 문자 "c"로 시작하려면 번호 매기기 스타일을 loweralpha로 설정하고 start 속성을 3으로 설정하세요.
====

=== 목록 마커 이스케이프하기

목록 마커로 시작하는 단락 텍스트가 있지만 목록 항목이 되도록 의도하지 않은 경우 속성 참조를 사용하여 패턴을 중단하여 해당 마커를 이스케이프해야 합니다.

행이 P.O. 상자 참조로 시작할 때의 경우를 고려해 보세요:

[source,asciidoc]
----
P. O. Box
이 단락이 정렬된 목록으로 파싱되는 것을 방지하려면 첫 번째 공백을 {empty}로 바꿔야 합니다.
----

[source,asciidoc]
----
P.{empty}O. Box
----

이제 단락은 단락으로 유지됩니다.

앞으로는 백슬래시를 사용하여 정렬된 목록 마커를 이스케이프할 수 있겠지만 현재는 불가능합니다.



[[checklists]]
== Lists - Checklists

체크리스트를 사용하여 목록 항목을 완료로 표시할 수 있습니다.

체크리스트(즉, 작업 목록)는 항목이 선택됨([*] 또는 [x]) 또는 선택되지 않음([ ])으로 표시된 정렬되지 않은 목록입니다. 다음은 예제입니다:

.Example 1. 체크리스트 구문
[source,asciidoc]
----
* [*] checked
* [x] also checked
* [ ] not checked
* normal list item
----

Example 1의 결과는 아래에 표시됩니다.
====
* [*] checked
* [x] also checked
* [ ] not checked
* normal list item
====

[TIP]
====
Example 1에서 볼 수 있듯이 목록의 모든 항목이 체크리스트 항목일 필요는 없습니다.
====

체크리스트가 HTML로 변환되면 체크박스 마크업은 적절한 선택 상태를 가진 HTML 체크박스로 변환됩니다. 항목이 선택되면 체크박스의 data-item-complete 속성이 1로 설정되고, 그렇지 않으면 0으로 설정됩니다. 체크박스는 항목의 글머리 기호 대신 사용됩니다.

AsciiDoc에서 생성된 HTML은 일반적으로 정적이므로 체크박스가 비활성화되어 간단한 표시로 나타납니다. 체크박스를 대화형(즉, 클릭 가능)으로 만들려면 체크리스트에 interactive 옵션을 추가하세요(여기에서는 Options Attribute에 대한 단축 구문을 사용하여 표시됨):

.Example 2. 대화형 체크박스가 있는 체크리스트
[source,asciidoc]
----
[%interactive]
* [*] checked
* [x] also checked
* [ ] not checked
* normal list item
----

Example 2의 결과는 아래에 표시됩니다.
====
[%interactive]
* [*] checked
* [x] also checked
* [ ] not checked
* normal list item
====



[[separating-lists]]
== Lists - Separating Lists

AsciiDoc에서 목록 항목은 서로 자연스럽게 끌어당깁니다. 인접한 행이 같은 목록 마커로 시작하면 빈 행으로 구분되더라도 같은 목록으로 결합됩니다. 인접한 행이 다른 목록 마커로 시작하면 빈 행으로 오프셋되더라도 중첩된 목록에 배치됩니다.

이러한 규칙은 목록 항목을 단일 목록으로 유지하기 쉽게 만듭니다. 그러나 별도의 목록을 만들고 싶다면 문제가 될 수 있습니다. 다행히도 이 동작을 강제로 변경하는 방법이 있습니다. 이 페이지에 설명된 기법은 모든 목록 유형에 적용됩니다.

=== 행 주석 사용하기

목록을 강제로 분리하려면 두 목록 사이에 양쪽에 빈 행으로 둘러싸인 행 주석(//)을 삽입할 수 있습니다.

다음은 인접한 두 개의 정렬되지 않은 목록을 분리하기 위해 행 주석을 배치할 위치를 보여주는 예제입니다. 행 주석 접두사 다음에 오는 -는 작성자에게 주석 행이 "목록 끝" 마커 역할을 한다는 힌트입니다:

[source,asciidoc]
----
* Apples
* Oranges

//-

* Walnuts
* Almonds
----

이 기법은 모든 유형의 목록을 분리하는 데 사용할 수 있습니다.

=== 블록 속성 행 사용하기

새 목록을 시작하는 또 다른 방법은 빈 행으로 오프셋된 두 번째 목록 위에 블록 속성 행(비어 있더라도)을 배치하는 것입니다.

다음은 인접한 정렬되지 않은 목록과 정렬된 목록을 분리하기 위해 블록 속성 행을 배치할 위치를 보여주는 예제입니다.

[source,asciidoc]
----
* Apples
* Oranges

[]
. Wash
. Slice
----

앞의 빈 행이 중요합니다. 해당 행이 없으면 정렬된 목록은 여전히 정렬된 목록 내부에 중첩됩니다. 두 번째 목록에 블록 속성이 필요한 경우 블록 속성 행에 추가할 수 있습니다.

이 기법은 모든 유형의 목록을 분리하는 데 사용할 수 있습니다.



[[complex-list-items]]
== Lists - Complex List Items


---

[[description-lists]]
== Description Lists
[[horizontal-description-list]]
=== Horizontal Description List
[[question-answer-lists]]
=== Question and Answer Lists
[[description-lists-with-marker]]
=== Description Lists With Marker

[[links]]
== Links
[[autolinks]]
=== Autolinks
[[url-macro]]
=== URL Macro
[[link-macro]]
=== Link Macro
[[troubleshooting-complex-urls]]
=== Troubleshooting Complex URLs
[[link-url-macro-attribute-parsing]]
=== Link & URL Macro Attribute Parsing
[[mailto-macro]]
=== Mailto Macro
[[link-url-mailto-macro-attributes-reference]]
=== Link, URL, and Mailto Macro Attributes Reference

[[cross-references]]
== Cross References
[[document-to-document-cross-references]]
=== Document to Document Cross References
[[cross-reference-text-styles]]
=== Cross Reference Text and Styles
[[validate-cross-references]]
=== Validate Cross References

---

[[footnotes]]
== Footnotes

AsciiDoc은 문서에 각주를 추가하기 위한 footnote 매크로를 제공합니다. 각주는 각주 목록의 항목에 대한 참조입니다. 각주는 참조 위치에서 AsciiDoc으로 정의되지만 텍스트는 각주 목록의 항목으로 추출됩니다. 첫 번째 발생 위치에 ID를 할당하고 후속 발생 위치에서 해당 ID를 참조하여 여러 위치에서 동일한 각주를 참조할 수 있습니다.

[NOTE]
====
Asciidoctor를 포함한 모든 AsciiDoc 프로세서는 현재 각주를 미주로 구현합니다. 각주의 배치와 번호 매김은 사용자 정의 변환기를 사용하여 사용자 지정할 수 있습니다.
====

=== 각주 매크로 문법

각주 매크로를 사용하여 문서에 각주를 삽입할 수 있습니다. 각주의 텍스트는 각주 매크로의 대괄호 사이에 정의됩니다(footnote\:[text]). 각주 매크로는 매크로의 대상을 사용하여 선택적 ID를 허용합니다(`footnote:id[text]`). ID를 지정하면 문서의 여러 위치에서 동일한 각주를 참조할 수 있습니다. 이전에 정의된 각주를 참조하려면 텍스트를 지정하지 않고 대상에 ID를 지정합니다(`footnote:id[]`).

_Example 1. 각주 문법_

[source,ASCIIDOC]
----
[source]
The hail-and-rainbow protocol can be initiated at five levels:
. doublefootnote:[The double hail-and-rainbow level makes my toes tingle.] [1][2]
. tertiary
. supernumerary
. supermassive
. apocalyptic
A bold statement!footnote:disclaimer[Opinions are my own.] [3]
Another outrageous statement.footnote:disclaimer[] [4]
----

[1] 각주 매크로를 직접 구두점 뒤에 삽입하세요. 각주 매크로는 단일 콜론(:)만 사용합니다.
[2] 각주의 내용을 대괄호([]) 안에 삽입하세요. 텍스트는 여러 줄에 걸쳐 있을 수 있습니다.
[3] 각주를 재사용할 계획이라면 대상 위치에 고유한 ID를 지정하세요.
[4] 기존 각주를 참조하려면 대상 슬롯에 각주의 ID만 지정하면 됩니다. 대괄호 사이의 텍스트는 비어 있어야 합니다. ID와 텍스트가 모두 지정되고 ID가 이전 각주에 의해 이미 정의된 경우 텍스트는 무시됩니다.

[TIP]
====
각주 매크로를 단어에 직접 인접하게 넣어야 하는 것이 읽기 어렵다는 것을 발견하면 빈 문자열로 해석되는 속성 참조를 사이에 삽입할 수 있습니다(예: `word{empty}footnote:[text]`).
====

각주는 문서 전체에서 연속적으로 번호가 매겨집니다.

Example 1의 결과는 아래에 표시됩니다.

====
The hail-and-rainbow protocol can be initiated at five levels
double[1]
tertiary
supernumerary
supermassive
apocalyptic
A bold statement![2]
Another outrageous statement.[2]

The double hail-and-rainbow level makes my toes tingle.
Opinions are my own.
====

일반 단락 텍스트와 마찬가지로 각주의 텍스트에서 텍스트 서식 마크업을 사용할 수 있습니다.

=== 각주 외부화

각주는 인라인 매크로를 사용하여 정의되므로 각주 내용은 주석을 달고 있는 텍스트와 함께 삽입되어야 합니다. 이 요구 사항은 텍스트를 읽기 더 어렵게 만들 수 있습니다. 문서 속성을 사용하여 각주를 외부화하면 이 문제를 해결할 수 있습니다.

각주를 포함하는 문서 속성을 정의할 때 원하는 대로 문서 속성의 이름을 지정할 수 있습니다. 일반적인 관행은 fn- 접두사를 사용하여 속성의 이름을 지정하는 것입니다. 속성의 이름은 fn-disclaimer처럼 자세할 수도 있고 fn-1처럼 간결할 수도 있습니다.

다음은 각주를 문서 속성으로 정의하고 속성 참조를 사용하여 삽입한 이전 예제입니다.

_Example 2. 외부화된 각주_
[source,ASCIIDOC]
----
:fn-hail-and-rainbow: footnote:[The double hail-and-rainbow level makes my toes tingle.]
:fn-disclaimer: footnote:disclaimer[Opinions are my own.]
The hail-and-rainbow protocol can be initiated at five levels:
. double{fn-hail-and-rainbow}
. tertiary
. supernumerary
. supermassive
. apocalyptic
A bold statement!{fn-disclaimer}
Another outrageous statement.{fn-disclaimer}
----

각주가 배치된 위치를 볼 수 있는 이점은 여전히 얻을 수 있지만 모든 잡음은 없습니다. 그리고 각주가 이제 문서 헤더에 정의되었으므로 include 파일로 더 외부화될 수 있습니다.

이 접근 방식은 속성 참조가 각주가 파싱되기 전에 확장되기 때문에 작동합니다. 그러나 각주의 텍스트에 텍스트 서식 마크업(예: *bold*)이 있는 경우에는 이 기법이 작동하지 않습니다. 해당 마크업은 해석되지 않습니다. 그 이유는 속성 대체(속성 참조 대체)가 인용구 대체(텍스트 서식 마크업 해석) 후에 적용되기 때문입니다. 각주의 텍스트에서 텍스트 서식 마크업을 사용하려면 pass:[] 매크로를 사용하여 속성 항목의 값에 대한 대체를 구성해야 합니다.

다음 예제는 텍스트 서식 마크업이 허용되도록 외부화된 각주의 텍스트에 적용되는 대체를 구성하는 방법을 보여줍니다.

_Example 3. 텍스트 서식이 있는 외부화된 각주_

[source,ASCIIDOC]
----
:fn-disclaimer: pass:c,q[footnote:disclaimer[Opinions are mine, and mine alone.]]
A bold statement!{fn-disclaimer}
Another outrageous statement.{fn-disclaimer}
----

pass 매크로의 c,q 대상은 프로세서에게 특수 문자 대체 후 인용구 대체를 적용하도록 지시합니다. 즉, 속성 참조를 사용하여 각주를 삽입할 때 각주 텍스트의 텍스트 서식이 이미 적용됩니다.


=== 제목의 각주
spec 이전 AsciiDoc에서는 제목(섹션 제목 및 개별 제목)의 각주가 공식적으로 지원되지 않습니다. 각주가 파싱되지만 제대로 작동한다는 보장은 없으며 해결 방법이 필요할 수 있습니다. 이 제한은 AsciiDoc 언어가 사양에 의해 정의되면 해제될 수 있습니다.

제목에 각주를 사용하면 각주 색인이 잘못되었다는 것을 알 수 있습니다(증분되지 않거나 순서가 맞지 않음). 그 이유는 제목(섹션 제목 및 개별 제목)이 ID 생성, 상호 참조 채우기 및 속성 참조의 즉각적인 해결을 위해 문서 순서에서 벗어나 변환되기 때문입니다.

이 문제를 해결하는 한 가지 방법은 각주를 포함하는 모든 제목에 명시적 ID와 reftext를 할당하는 것입니다. 예를 들면 다음과 같습니다:

[source,asciidoc]
----
See <<heading>>.
[[heading,Heading]]
== Headingfootnote:[This is a heading with a footnote]
----

제목에 명시적 ID와 reftext를 할당하면 제목이 렌더링되기 전에 대체가 적용되는 것을 방지하여 각주 매크로가 문서 순서대로 처리될 수 있습니다. 이 해결 방법은 또한 각주 번호가 xref의 텍스트에 다시 나타나는 것을 방지합니다. 그러나 제목에서 속성 참조를 사용하지 않도록 해야 합니다. 이는 대체가 즉시 적용되도록 하므로 각주가 문서 순서에서 벗어나 처리될 수 있기 때문입니다.

[[images]]
== Images
[[set-the-images-directory]]
== Set the Images Directory
[[insert-images-from-a-url]]
== Insert Images from a URL
[[position-and-frame-images]]
== Position and Frame Images
[[add-link-to-image]]
== Add Link to Image
[[adjust-image-sizes]]
== Adjust Image Sizes
[[specify-image-format]]
== Specify Image Format
[[svg-images]]
== SVG Images
[[images-reference]]
== Images Reference

---

[[audio-and-video]]
== Audio and Video

===
[[icons]]
== Icons
[[image-icons-mode]]
== Image Icons Mode
[[font-icons-mode]]
== Font Icons Mode
[[icon-macro]]
== Icon Macro


[[keyboard-macro]]
== Keyboard Macro

[[button-menu-ui-macros]]
== Button and Menu UI Macros

[[admonitions]]
== Admonitions

[[sidebars]]
== Sidebars

[[example-blocks]]
== Example Blocks

[[blockquotes]]
== Blockquotes

[[verses]]
== Verses

[[verbatim-source-blocks]]
== Verbatim and Source Blocks
[[source-code-blocks]]
=== Source Code Blocks
[[source-highlighting]]
==== Source Highlighting
[[highlight-select-lines]]
==== Highlight Select Lines
[[highlight-php-source-code]]
==== Highlight PHP Source Code
[[listing-blocks]]
=== Listing Blocks

[[literal-blocks]]
=== Literal Blocks

[[callouts]]
=== Callouts

[[tables]]
== Tables
[[build-basic-table]]
=== Build a Basic Table
[[add-a-title]]
=== Add a Title
[[customize-title-label]]
==== Customize the Title Label
[[turn-off-title-label]]
==== Turn Off the Title Label
[[add-columns-table]]
=== Add Columns to a Table
[[adjust-column-widths]]
==== Adjust Column Widths
[[align-content-column]]
==== Align Content by Column
[[format-content-column]]
==== Format Content by Column
[[add-cells-rows-table]]
=== Add Cells and Rows to a Table
[[create-header-row]]
==== Create a Header Row
[[create-footer-row]]
==== Create a Footer Row
[[align-content-cell]]
==== Align Content by Cell
[[format-content-cell]]
==== Format Content by Cell
[[span-columns-rows]]
==== Span Columns and Rows
[[duplicate-cells]]
==== Duplicate Cells
[[table-width]]
=== Table Width
[[table-borders]]
=== Table Borders
[[table-striping]]
=== Table Striping
[[table-orientation]]
=== Table Orientation
[[assign-role-table]]
=== Assign a Role to a Table
[[nesting-tables]]
=== Nesting Tables
[[csv-tsv-dsv-data]]
=== CSV, TSV and DSV Data
[[table-reference]]
=== Table Reference

[[equations-formulas]]
== Equations and Formulas (STEM)

[[open-blocks]]
== Open Blocks

[[collapsible-blocks]]
== Collapsible Blocks

[[comments]]
== Comments

[[automatic-toc]]
== Automatic Table of Contents
[[customize-toc-title]]
=== Customize the TOC Title
[[adjust-toc-depth]]
=== Adjust the TOC Depth
[[position-toc]]
=== Position the TOC
[[toc-attributes-reference]]
=== TOC Attributes Reference

[[docinfo-files]]
== Docinfo Files

[[includes]]
== Includes
[[offset-section-levels]]
=== Offset Section Levels
[[indent-included-content]]
=== Indent Included Content
[[use-include-file-multiple-times]]
=== Use an Include File Multiple Times
[[include-list-item-content]]
=== Include List Item Content
[[include-content-tagged-regions]]
=== Include Content by Tagged Regions
[[include-content-line-ranges]]
=== Include Content by Line Ranges
[[include-content-uri]]
=== Include Content by URI

[[conditionals]]
== Conditionals
[[ifdef-directives]]
=== ifdef and ifndef Directives
[[ifeval-directive]]
=== ifeval Directive


---


[[substitutions]]
== Substitutions
[[special-characters]]
=== Substitutions - Special Characters
[[quotes]]
=== Substitutions - Quotes
[[attribute-references]]
=== Substitutions - Attribute References
[[character-replacements]]
=== Substitutions - Character Replacements
[[macros]]
=== Substitutions - Macros
[[post-replacements]]
=== Substitutions - Post Replacements
[[customize-substitutions-blocks]]
=== Substitutions - Customize the Substitutions Applied to Blocks
[[customize-substitutions-text]]
=== Substitutions - Customize the Substitutions Applied to Text
[[escape-prevent-substitutions]]
=== Substitutions - Escape and Prevent Substitutions



[[passthroughs]]
== Passthroughs
[[passthrough-blocks]]
=== Passthroughs - Passthrough Blocks
[[inline-passthroughs]]
=== Passthroughs - Inline Passthroughs



[[reference]]
== Reference
[[syntax-quick-reference]]
=== Reference - Syntax Quick Reference
[[faq]]
=== Reference - Frequently Asked Questions (FAQ)
[[compare-asciidoc-markdown]]
=== Reference - Compare AsciiDoc to Markdown
[[document-attributes-reference]]
=== Reference - Document Attributes Reference
[[character-replacement-attributes-reference]]
=== Reference - Character Replacement Attributes Reference



[[reference-glossary-of-terms]]
=== Reference - Glossary of Terms

[WORK IN PROGRESS]
====
이 용어집은 진행 중인 작업입니다. AsciiDoc의 모든 용어를 포함하지는 않습니다.
====

*속성 참조(attribute reference)*
....
문서 속성의 값을 역참조하기 위한 표현식.
....

*속성 목록(attrlist)*
....
요소(예: 블록, 블록 매크로, 인라인 매크로) 또는 include 지시문에 대한 속성을 정의하는 소스 텍스트.
....

*권고(admonition)*
....
우선순위를 나타내는 레이블이나 아이콘이 있는 주의 단락 또는 블록.
....

*백엔드(backend)*
....
예상되는 출력 형식에 대한 모니커; 사용할 변환기를 선택하는 키로 사용됨; 종종 변환기의 이름과 같은 의미로 사용됨(예: "html5" 백엔드).
....

*블록 요소(block element)*
....
AsciiDoc 문서의 행 지향 콘텐츠 덩어리.
....

*블록 속성(block attribute)*
....
구분된 블록 또는 단락과 연결된 속성; 이러한 속성은 블록의 처리에 영향을 미칠 수 있으며 블록 프로세서에 사용할 수 있지만 속성 참조를 사용하여 참조할 수 없음.
....

*블록 이름(block name)*
....
사용자 정의 블록을 참조하는 데 사용되며, 임의의 이름을 하나 이상의 컨텍스트에 매핑할 수 있음; 권고 블록과 같은 기본 제공 블록의 스타일과 유사한 역할을 함.
....

*블록 스타일(block style)*
....
블록의 컨텍스트를 특수화하는 수정자.
....

*기본 제공 속성(built-in attribute)*
....
처리, 통합, 스타일링 및 지역화를 제어하는 문서 속성.
....

*콘텐츠 모델(content model)*
....
블록의 콘텐츠가 구문 분석되고 처리되는 방식을 결정함(예: 단순, 복합, 축어적, 원시 등).
....

*컨텍스트(context)*
....
요소의 유형; 요소의 기본 기능을 설명함(예: 사이드바, 목록, 예제).
....

*변환기(converter)*
....
AsciiDoc 프로세서가 구문 분석된 AsciiDoc 문서를 주어진 출력 형식으로 변환하기 위해 호출하는 소프트웨어 구성 요소; 변환기와 출력 형식은 백엔드 식별자를 사용하여 상호 연관됨.
....

*상호 참조(cross reference)*
....
문서의 한 위치에서 앵커로 표시된 다른 위치로의 링크.
....

*문서 속성(document attribute)*
....
문서(노드)와 연결된 속성; 즉, 전역 문서 속성 사전의 속성; 이러한 속성의 값은 속성 참조를 사용하여 참조할 수 있음; 헤더에 정의된 경우 문서 속성을 헤더 속성이라고 함.
....

*요소(element)*
....
소스 또는 출력 문서의 개별 콘텐츠. 분기(자식 요소 포함) 또는 리프(자식 요소 포함하지 않음)일 수 있음.
....

*요소 속성(element attribute)*
....
블록, 매크로, 서식 있는 텍스트 또는 include 지시문과 연결된 속성; 이러한 속성은 요소(또는 include 지시문)의 처리에 영향을 미칠 수 있으며 문서 모델에서 사용할 수 있음; 그러나 이러한 속성의 값은 속성 참조를 사용하여 확인할 수 없음.
....

*환경 속성(environment attribute)*
....
런타임 환경에 관한 정보를 제공하는 동적 문서 속성.
....

*헤더 속성(header attribute)*
....
문서 헤더에 정의된 문서 속성; 문서의 모든 노드에서 볼 수 있음; 종종 소스 하이라이터 또는 아이콘 모드와 같은 전역 설정에 필요함.
....

*인라인 요소(inline element)*
....
AsciiDoc 문서의 블록 요소 또는 해당 속성 중 하나 내의 구(즉, 콘텐츠 범위).
....

*목록 연속(list continuation)*
....
인접한 텍스트 행을 목록 항목에 연결하는 자체 행의 더하기 기호(+).
....

*매크로(macro)*
....
비텍스트 요소를 나타내거나 제공된 메타데이터를 사용하여 텍스트로 확장하는 구문.
....

*매크로 속성(macro attribute)*
....
블록 또는 인라인 매크로와 연결된 속성; 이러한 속성은 매크로의 처리에 영향을 미칠 수 있으며 매크로 프로세서에 사용할 수 있지만 속성 참조를 사용하여 참조할 수 없음.
....

*노드(node)*
....
구문 분석된 문서 모델의 블록 또는 인라인 요소의 메모리 내 표현.
....

*미리 정의된 속성(predefined attribute)*
....
편의를 위해 정의된 문서 속성; 종종 특수 콘텐츠 문자를 삽입하는 데 사용됨.
....

*구조적 컨테이너(structural container)*
....
AsciiDoc 언어에서 정의한 재사용 가능한 고정 블록 인클로저(구분된 영역) 집합; 블록의 콘텐츠 모델을 암시함; 블록 콘텐츠의 경계를 정의하는 일치하는 구분된 행 쌍으로 특징지어짐.
....

*인용 텍스트(quoted text)*
....
강조 또는 특별한 의미를 부여하기 위해 특수 문장 부호로 묶인 텍스트.
....

*사용자 정의 속성(user-defined attribute)*
....
콘텐츠 작성자가 정의한 문서 속성; 재사용 가능한 콘텐츠 저장 및 조건부 포함 제어에 사용됨.
....